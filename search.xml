<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Transformer学习记录</title>
    <url>/blog/2023/09/21/Transformer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p><a href="http://arxiv.org/abs/1706.03762">Attention is All You Need</a>是transformer的开山之作。论文相关的Tensorflow的代码可以从<a href="https://github.com/tensorflow/tensor2tensor">GitHub</a>获取，当然也有很多人对它进行了<a href="https://github.com/huggingface/transformers">二次开发</a>.</p>
<p>文中，我试图把模型简化一点，逐一介绍里面的核心概念，希望让初学者也能轻易理解.</p>
<h2 id="机器翻译">机器翻译</h2>
<p><img src="%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91.png" alt="机器翻译" title="机器翻译"></p>
<p>transformer一开始提出主要是用于翻译工作,所以我们不妨从翻译的原理开始认识它.</p>
<p>首先,我们可以观察到翻译是由两部分<strong>encoder</strong>和<strong>decoder</strong>组成的;这里<strong>encoder</strong>会吸收需要被翻译的句子,也就是<em>Machine Learning</em>而<strong>decoder</strong>会输出对应的<em>机器学习</em></p>
<p>具体的讲,整个翻译工作分为以下几步:</p>
<h3 id="语句处理">语句处理</h3>
<p>对于一段话而言,词语本身的意思和词语之间的相对位置同样重要.所以翻译器会首先通过<strong>token embeddings</strong>获取每一个词的本身的意思对应的向量和词语在句子位置中对应的向量;并且把两者加起来.这样每一个词就可以用一个向量同时表示意思和位置.对应的,一个句子就可以用一个矩阵表达.</p>
<h3 id="处理句子矩阵">处理句子矩阵</h3>
<p>然后,我们把刚刚得到的句子的向量矩阵$X$传入<strong>encoder</strong>中,随后会输出一个含有句子所有信息的编码句子$C$.$X$和$C$形状完全相同都是$n\times d$,这里的$n$表示句子中含有的单词的数量,$d$表示一个单词的向量维度&lt;文中采用$d=512$&gt;.</p>
<h3 id="翻译">翻译</h3>
<p>现在我们把<strong>encoder</strong>输出的$C$传入<strong>decoder</strong>中,也就是把需要被翻译的语句的信息传入.同时传入一个特殊符号&quot;$“,它表示一句话的开始,随后<strong>decoder</strong>就会根据$C$和”$“输出第一个汉字&quot;<strong>机</strong>”.</p>
<p>然后,“<strong>$+机</strong>&quot;会代替原来的$的位置作为输入和$C$经过<strong>decoder</strong>输出&quot;<strong>器</strong>”.</p>
<p>这样周而复始,直到输出另一个特殊的代表句子结束的符号&quot;#&quot;.</p>
<p>下面,我们就具体介绍transformer是怎么实现这个过程的.</p>
<h3 id="Transformer的整体架构">Transformer的整体架构</h3>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>可以看出,transformer的和刚才的翻译器在形式上是类似的,下面就具体展开说说每一部分是在做什么.</p>
<h2 id="Transformer的输入">Transformer的输入</h2>
<h3 id="input-Embedding">input Embedding</h3>
<p>Inputs,也就是我们输入需要被翻译的文字,在通过embedding vector之后会映射到一个高维的空间中,也就是说词的&quot;feature&quot;被提取了出来,并且被放在了一个矩阵中,不妨称之为<strong>词义矩阵</strong></p>
<h3 id="positional-Encoding">positional Encoding</h3>
<p>获得句子中的每一个单词的位置信息,同样形成了一个矩阵,不妨称之为<strong>位置矩阵</strong>.然后把词义矩阵和位置矩阵相加,得到的就是encoder的输入.</p>
<p>具体的位置矩阵的算法有很多,这里介绍一种比较简单的方法:</p>
<p>$$<br>
PE_{(pos,2i)}=\sin(\frac{pos}{10000^{\frac{2i}{d}}}),<br>
PE_{(pos,2i+1)}=\cos(\frac{pos}{10000^{\frac{2i}{d}}})<br>
$$</p>
<p>这里的$PE$表示词的位置信息;$pos$表示词在句子中的位置;$d$表示词的维度,也就是词的&quot;feature&quot;所需要的度量的数量;$2i$就是偶数维度,$2i+1$就是奇数维度.采用这种计算方法及足够简单,又很好的满足了几个条件:</p>
<ol>
<li>保证了PE和词的大小一样,也就是词义矩阵和位置矩阵大小一样</li>
<li>PE可以适应验证集中出现比训练集中句子更长的情况</li>
<li>有利于获得相对位置的信息,比如两个单词相距$k$,知道一个就可以快速得到另一个:$\sin(pos+k)=\sin(pos)\cos(k)+\cos(pos)\sin(k),cos(pos+k)=\cos(pos)\cos(k)-\sin(pos)\sin(k)$</li>
</ol>
<h3 id="进入encoder">进入encoder</h3>
<p>把input embedding 和positional embedding相加就能得到表示句子的矩阵$X$,它随后进入了encoder</p>
<h2 id="Self-Attention-自注意力机制">Self-Attention(自注意力机制)</h2>
<p>在进入encoder之前,有必要先介绍以下自注意力机制,这也是transformer的精髓所在,再看一眼整体架构.</p>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>请注意那些<strong>浅橙色</strong>的色块,这里的<strong>Self-Attention</strong>正是我们接下来要关注的,而且这个结构在encoder和decoder中是一样的.至于&quot;Multi-Head Attention&quot;和&quot;Masked Multi-Head Attention&quot;本质上也是一样的,只是多了一些修饰.</p>
<h3 id="Self-Attention的结构">Self-Attention的结构</h3>
<p>首先看一个简单的例子了解什么是<strong>注意力</strong>.如下图,所谓注意力就是一个词和另一个词的联系的紧密程度.这里<strong>绿色的The</strong>就是我们要考察的的对象,我们想知道它和句子中的其他的联系的紧密程度如何,所以我们用<strong>The</strong>的表示向量$\vec x_{the}$和句子中其他单词的表示向量$\vec x_{others}$做内积.然后使用softmax进行归一化,也就是得到<strong>The</strong>和其他词语之间的关系的打分.</p>
<p>然后,我们利用这个’打分系统’对句子中的每一个词打分并相加,就得到了<strong>The</strong>在整个句子中的占有的<strong>注意力</strong></p>
<p>事实上,我们可以看出,由于&quot;The,weather,is,nice,today&quot;中的每一个词都要有相同的操作,所以可以把整个过程看作是矩阵乘法,也就是:</p>
<p>$$<br>
Attention=softmax(X\cdot X^{T})\cdot X<br>
$$</p>
<p>这里,输入和输出的矩阵的形状是一摸一样的,只是说,根据整个句子的&quot;句意矩阵&quot;对句子中的每一个词的&quot;表示向量&quot;做出了调整.而且,由于是自己和自己相乘,所以这个过程就是<strong>自</strong>注意力机制.</p>
<p>同时,这个过程和人类的语言习惯也是相统一的,同样的词语必然需要根据不同的句子赋予不同的意义,比如&quot;苹果手机&quot;和&quot;收集苹果&quot;.</p>
<p><img src="%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BE%8B%E5%AD%90.png" alt="例子" title="例子"></p>
<h3 id="Self-Attention-in-Transformer">Self-Attention in Transformer</h3>
<p>然后我们看看transformer是如何应用self-attention的.</p>
<p><img src="%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6.png" alt="Self-Attention" title="Self-Attention"></p>
<p>为了增强自注意力的效果,在正式的计算之前,先使用矩阵$W_Q$(查询矩阵),$W_K$(键矩阵),$W_V$(值矩阵),对input($X$)进行修正.</p>
<p>$$<br>
Q=X\cdot W_Q\<br>
K=X\cdot W_K    \<br>
V=X\cdot W_V<br>
$$</p>
<p>这样得到了三个不同的矩阵Q(查询),K(键值),V(值).这里的$Q,K,V$相比于$X$行数不变,列数有变化;等价于单词的数量不变但是衡量每一个单词的特征的数量发生了改变.</p>
<p>然后,这三个被传入上图所示的机制,计算实现Self-Attention:</p>
<p>$$<br>
Z=Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V<br>
$$</p>
<p>下面这个图或许可以更好的表达整个过程.</p>
<p><img src="self-attention.png" alt="self-attention" title="self-attention"></p>
<p>这里,为了防止内积过大,因此除以$d_k$,也即是$K$的列数.同样的,整个过程没有改变X的行数,只是改变了列数.这里的$Z$就是self-Attention的输出矩阵.</p>
<h3 id="Multi-Head-Attention">Multi-Head Attention</h3>
<p>在上一步，我们已经通过 Self-Attention 计算得到输出矩阵 $Z$，但是这还不够.其中的一个原因在于,这样得到的句子的信息不够,在准确率上有所不足.解决这个问题的本质就是要从句子中提取更多的信息,这里一个朴素的想法就是,‘多读几遍’.而Multi-Head Attention就是这样的想法.</p>
<p><img src="Multi-Head%20Attention.png" alt="Multi-Head Attention" title="Multi-Head Attention"></p>
<p>从上图可以看到 Multi-Head Attention 包含多个 Self-Attention 层，首先将输入$X$分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵Z。这里是 h=8 时候的情况，也就是会得到 8 个输出矩阵Z。</p>
<p>然后把输出的$Z_i$拼接到一起,再使用一个矩阵做一个线性变化,使得multi-head attention前后的矩阵大小不变.类比的讲,我们可以很自然的想到,这个线性变换(Linear)就相当于把好几次阅读得到的信息融合在了一起.</p>
<p>下面的这张图有一点小问题,最左边的矩阵的$X$和$D_X$写反了,中间的小矩阵倒是写的是正确的;不过这个图看起来更直观,所以还是放在这里.</p>
<p><img src="Multi-Head%20Attention-%E7%A4%BA%E6%84%8F.png" alt="MHA表示" title="MHA表示"></p>
<h3 id="Multi-Layer-Self-Attention">Multi-Layer Self-Attention</h3>
<p>这个想法我觉得太自然不过了,知道考虑考虑我们的MLP就可以明显的看出网络数量上升的好处.不所以这里不是想讨论这样的机制,而是觉得这个图很有意思,我第一次没有看懂,感觉值得拿出来聊聊.</p>
<p><img src="Multi-Layer%20Self-Attention.png" alt="Multi-Layer Self-Attention" title="Multi-Layer Self-Attention"></p>
<p>上图中,每一个大矩形包裹的就是一个Self-Attention in Transformer,<strong>一个六边形表示一个词和其他词的注意力</strong>,仔细看看可以看到每一个六边形的红色点是不一样的.在一个Self-Attention in Transformer实现之后,使用某种非线性函数$f(\cdot)$再把输出传到下一个Self-Attention in Transformer中,如此循环几次即可.</p>
<h2 id="Encoder">Encoder</h2>
<p>在讨论完Self-Attention之后我们总算可以正式的进入Transformer了.</p>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>上图左边浅橙色的部分就是我们的encoder,或者说encoder block,因为我们要把这个结构反复使用$N$次.</p>
<p>之前我们已经着重讲过了Multi-Head Attention了,所以这里把目光放在Add &amp; Norm和Feed Forward上.</p>
<h3 id="Add">Add</h3>
<p>Add也就是残差连接,用公式表达就是$X + MultiHeadAttention(X)$,这样的操作在RNN中就已经见到了,好处是避免了反向传播中的梯度消失.</p>
<p>这里就可以看到保持$Z$和$X$的形状一样的好处了.</p>
<h3 id="Norm">Norm</h3>
<p>归一化就更没什么好说了,就是高斯/正太化了.$LayerNorm(X+MultiHeadAttention(X))$<br>
Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</p>
<h3 id="Feed-Forward">Feed Forward</h3>
<p>Feed Forward 层比较简单，是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数$ReLu(XW_1+b_1)W_2+b_2$</p>
<h3 id="我来组成头部">我来组成头部</h3>
<p>Multi-Head Attention, Feed Forward, Add &amp; Norm 就可以构造出一个 Encoder block，Encoder block 接收输入矩阵 $X$，并输出一个矩阵 $C$.通过多个 Encoder block 叠加组成 Encoder。</p>
<p>第一个 Encoder block 的输入为句子单词的表示向量矩阵，后续 Encoder block 的输入是前一个 Encoder block 的输出，最后一个 Encoder block 输出的矩阵就是编码信息矩阵 C，这一矩阵后续会用到 Decoder 中。</p>
<h2 id="Decoder">Decoder</h2>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>上图右边浅橙色的部分就是我们的decoder,或者说decoder block,因为我们同样要把这个结构反复使用$N$次.</p>
<p>这里虽然右两个但是本质上是一样的,都是我们的Multi-Head Attention,只是输入的$X$和之前的不一样了.</p>
<p>概况的说就是:</p>
<ul>
<li>第一个 Multi-Head Attention 层采用了 Masked</li>
<li>第二个 Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q使用上一个 Decoder block 的输出或者输入$X$计算</li>
</ul>
<blockquote>
<p>这里不妨想一想为什么有&quot;Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算&quot;这个安排.</p>
</blockquote>
<h3 id="Mask-Multi-Head-Attention">Mask Multi-Head Attention</h3>
<p>Mask,遮挡,我感觉这是很符合直觉,但是我想不到的东西,就是听了别人的介绍感觉平平无奇,但是自己去想绝对想不到的东西.</p>
<p>它来自一种现实,就是我们做翻译的时候,只知道翻译之后的内容的前文而不知道后文.<s>想象你正在看一本英文书,英文的内容自然是完整的,但是中文的意思却是一个一个顺序出现的</s>.所以,在计算<strong>注意力</strong>的时候就要屏蔽掉这个词语和那些句子中在它后面的词语的联系.<s>感觉这里有点绕</s></p>
<p>不知道你还记不记得<strong>注意力</strong>的概念,其实就是一句话中,一个单词和其它所有的单词的联系的紧密程度,一般的度量就是灵感单词的<strong>表示向量</strong>的内积的大小,由于句子中的每一个词都需要得到自己的注意力,所以实际计算的时候是句子的<strong>词义矩阵</strong>和他本身的转置的点乘.</p>
<p>但是,前文也说过了,在transformer中,为了更好的表现,我们使用线性变换把$X$转化为了$Q,K,V$,而且还说过$Z=Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V$.不知道这里你能不能看出来哪个部分是<strong>注意力矩阵</strong><s>这是我现造的词</s>.</p>
<p>其实是$Q\cdot K^{T}$,我们只要再用一个mask矩阵,和他做点乘就好,也即是$Q\cdot K^T\cdot mask$.</p>
<p>那么,什么样的mask矩阵可以满足这样的要求?如下所示:</p>
<p>$$\begin{bmatrix}<br>
{1}&amp;{0}&amp;{\cdots}&amp;{0}\<br>
{1}&amp;{1}&amp;{\cdots}&amp;{0}\<br>
{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>
{1}&amp;{1}&amp;{\cdots}&amp;{0}\<br>
\end{bmatrix}$$</p>
<p>这样一来,我们的attention就会演变成这样:$Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}\cdot Mask}{\sqrt{d_k}})\cdot V$</p>
<p>我们得到一个 Mask Self-Attention 的输出矩阵 ，和 Encoder 类似，通过 Multi-Head Attention 拼接多个输出然后线性变换,得到第一个 Multi-Head Attention 的输出Z，Z与输入X维度一样.</p>
<blockquote>
<p>事实上,在我要写Multi-Head Attention-2的时候,我忽然意识到,这里可能会产生一点歧义;就是,Mask Multi-Head Attention的输入.</p>
<p>我想说的是,Mask Multi-Head Attention的输入和encoder没有显示的关系,<s>第二个decoder block之后自然会有隐式的联系</s>!Mask Multi-Head Attention的输入中的$Q,K,V$是一个矩阵$X$变换得到的!</p>
</blockquote>
<h3 id="Multi-Head-Attention-2">Multi-Head Attention-2</h3>
<p>好吧,Multi-Head Attention-2也很好理解.唯一值得注意的就是其中 Self-Attention 的 $K, V$矩阵不是使用 上一个 Decoder block 的输出计算的，而是使用 Encoder 的编码信息矩阵 $C$ 计算的.</p>
<p>不知道你还记不记得之前的问题.</p>
<blockquote>
<p>这里不妨想一想为什么有&quot;Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算&quot;这个安排.</p>
</blockquote>
<p>其实不难回答,想想看我们现在的$Q,K,V$分别是怎么得到的:</p>
<p>$$<br>
Q=X\cdot W_Q\<br>
K=C\cdot W_K    \<br>
V=C\cdot W_V<br>
$$</p>
<p>再想想看,什么是注意力:$Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V$我们相当于考察了输入的$X$,<s>比如是一个start标志</s>,和需要被翻译的句子中的内容的关系;然后根据这个关系,对被翻译的句子中的内容进行调节.</p>
<p>这样做的好处是在 Decoder 的时候，每一个输出的单词都可以利用到 Encoder 所有单词的信息.</p>
<h2 id="Softmax">Softmax</h2>
<p>结束了Decoder,因为它也是一个&quot;Multi-Head&quot;,所以先做一个线性变换,使大小和一开始一样.然后使用softmax完成打分.</p>
<p>再后面就和MLP的后续没有任何区别,和decoder输入的$X$比较,得到loss和正确率,选择合适的优化器求梯度等等.</p>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>Transformer 没有利用单词的顺序信息的，需要在输入中添加位置 Embedding.</p>
</li>
<li>
<p>Self-Attention 结构是Transformer 的重点，其中用到的 Q, K, V矩阵通过$X$线性变换得到.</p>
</li>
<li>
<p>Multi-Head Attention 中有多个 Self-Attention，目的是捕获单词之间更多的联系.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>CS231n-深度学习与计算机视觉-RNN</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>免疫生物学-一周目</title>
    <url>/blog/2023/09/20/%E5%85%8D%E7%96%AB%E7%94%9F%E7%89%A9%E5%AD%A6-%E4%B8%80%E5%91%A8%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="免疫细胞的来源">免疫细胞的来源</h2>
<h3 id="骨髓和淋巴系统">骨髓和淋巴系统</h3>
<p>身体中的绝大多数免疫细胞来自于<strong>多能造血干细胞(pluripotent hematopoietic stem cells)</strong>,只有很少的一部分的分布在中枢神经系统的吞噬细胞有其他的来源的.这里我们只考虑前者.多能造血干细胞在骨髓中完成分化后,一部分细胞保留在骨髓中实现成熟,比如B细胞;一部分细胞迁移到其他免疫器官,比如<strong>胸腺</strong>中成熟,比如T细胞;但是有意思的是,T细胞(T-lymphocytes)的T并不是来自胸腺(Thymus).不论在哪里成熟,免疫细胞在成熟之后就会进入到**淋巴系统(lymphatic system)**中,淋巴系统会接收组织液中的淋巴细胞,在锁骨下实现和血液的交换.</p>
<h3 id="骨髓造血干细胞的演化">骨髓造血干细胞的演化</h3>
<p>所有的血细胞,包括运输氧气的红细胞(red blood cells),修复破损的血小板(platelets)和免疫系统的白细胞(white blood cells)都是通过骨髓造血干细胞(hematopoietic stem cells,HSCs)分化而来的.HSCs随后会分化为淋巴细胞系(lymphoid)和骨髓细胞系(myeloid)的直接祖细胞,下图对这个过程有着详细的描述.</p>
<p><img src="%E5%85%8D%E7%96%AB%E7%BB%86%E8%83%9E%E7%9A%84%E6%BC%94%E5%8C%96.png" alt="多能细胞(pliripotent cells)分化为共同淋巴祖细胞(common lymphoid progenitor)和共同骨髓祖细胞(common myeloid progenitor).前者会进一步分化为淋巴系(lymphoid lineage);这些包括B细胞(B Cells),T 细胞(T Cells),自然杀伤细胞(natural killer cells,NK),先天淋巴细胞(innate lymphoid cells,ILCs),未成熟的树突状细胞(dendritic cells).后者会分化为骨髓系(myeloid lineage);这些包括其余的白细胞,红细胞(red blood cells,erythrocytes),会进一步演化为血小板的巨核细胞(megakaryocytes).t 淋巴细胞和 B 淋巴细胞与其他白细胞的区别在于它们具有抗原受体，而它们之间的区别在于它们的分化部位（分别是胸腺和骨髓）遇到抗原后，B细胞分化为分泌抗体的浆细胞，而T细胞则分化为具有多种功能的效应T细胞。与 t 细胞和 B 细胞不同，ILC 和 nK 细胞缺乏抗原特异性。其余的白细胞是单核细胞(monocytes)、树突状细胞(dendritic cells)、中性粒细胞(neutrophils)、嗜酸性粒细胞(eosinophils)和嗜碱性粒细胞(basophils)。其中最后三种在血液中循环，被称为粒细胞(granulocytes)，因为细胞质颗粒的染色使这些细胞在血涂片中具有独特的外观，或者被称为多形核白细胞，因为它们的细胞核形状不规则。未成熟的树突状细胞(Immature dendritic cells)是进入组织的吞噬细胞(phagocytic cells)；它们在遇到潜在的病原体后成熟。大多数树突状细胞源自骨髓共同祖细胞，但有些也可能源自淋巴共同祖细胞。单核细胞进入组织，在那里分化成吞噬巨噬细胞或树突状细胞。肥大细胞(monocytes)也进入组织并在那里完成成熟。" title="免疫细胞的演化"></p>
<blockquote>
<p>多能细胞(pliripotent cells)分化为共同淋巴祖细胞(common lymphoid progenitor)和共同骨髓祖细胞(common myeloid progenitor).前者会进一步分化为淋巴系(lymphoid lineage);这些包括B细胞(B Cells),T 细胞(T Cells),自然杀伤细胞(natural killer cells,NK),先天淋巴细胞(innate lymphoid cells,ILCs),未成熟的树突状细胞(dendritic cells).后者会分化为骨髓系(myeloid lineage);这些包括其余的白细胞,红细胞(red blood cells,erythrocytes),会进一步演化为血小板的巨核细胞(megakaryocytes).t 淋巴细胞和 B 淋巴细胞与其他白细胞的区别在于它们具有抗原受体，而它们之间的区别在于它们的分化部位（分别是胸腺和骨髓）遇到抗原后，B细胞分化为分泌抗体的浆细胞，而T细胞则分化为具有多种功能的效应T细胞。与 t 细胞和 B 细胞不同，ILC 和 nK 细胞缺乏抗原特异性。其余的白细胞是单核细胞(monocytes)、树突状细胞(dendritic cells)、中性粒细胞(neutrophils)、嗜酸性粒细胞(eosinophils)和嗜碱性粒细胞(basophils)。其中最后三种在血液中循环，被称为粒细胞(granulocytes)，因为细胞质颗粒的染色使这些细胞在血涂片中具有独特的外观，或者被称为多形核白细胞，因为它们的细胞核形状不规则。未成熟的树突状细胞(Immature dendritic cells)是进入组织的吞噬细胞(phagocytic cells)；它们在遇到潜在的病原体后成熟。大多数树突状细胞源自骨髓共同祖细胞，但有些也可能源自淋巴共同祖细胞。单核细胞进入组织，在那里分化成吞噬巨噬细胞或树突状细胞。肥大细胞(monocytes)也进入组织并在那里完成成熟。</p>
</blockquote>
<h2 id="淋巴系统">淋巴系统</h2>
<h3 id="淋巴细胞在骨髓和胸腺中成熟然后分布在全身的淋巴组织">淋巴细胞在骨髓和胸腺中成熟然后分布在全身的淋巴组织</h3>
<p>淋巴细胞在血液(blood)和淋巴液(lymph)中循环，并且在淋巴组织或淋巴器官中也大量存在，所谓淋巴器官就是其他非淋巴细胞的包裹下的淋巴细胞的聚集体。淋巴器官可大致分为中央(central lymphoid organs)或初级淋巴器官(primary lymphoid organs)，其中产生淋巴细胞；以及外周(peripheral)或次级(secondary)淋巴器官，其中维持成熟的幼稚淋巴细胞并启动适应性免疫反应。中央淋巴器官是骨髓(bone marrow)和胸腺(thymus)。外周淋巴器官包括淋巴结(lymph nodes)、脾脏(spleen)、肠道粘膜淋巴组织(mucosal lymphoid tissues of the gut)、鼻腔和呼吸道(nasal and respiratory tract)、泌尿生殖道(urogenital tract)和其他粘膜。主要淋巴组织的位置如图所示。淋巴结通过淋巴管系统(system of lymphatic vessels)相互连接，淋巴管从组织中排出细胞外液，将其携带通过淋巴结，然后将其存回到血液中.</p>
<p>产生 B 淋巴细胞和 T 淋巴细胞的祖细胞起源于骨髓。 B 细胞在骨髓内完成发育。虽然 B 淋巴细胞中的“B”最初代表法氏囊（ bursa of Fabricius），这是幼鸡体内淋巴细胞成熟的淋巴器官，但它对于骨髓来说是一个有用的助记符。 T 淋巴细胞的未成熟前体迁移到胸腺，并在那里完成发育，并由此得名。一旦完成成熟，两种类型的淋巴细胞都会以成熟的幼稚淋巴细胞(mature naive lymphocytes)的形式进入血流，并在外周淋巴组织中持续循环。</p>
<p>mature naive lymphocytes,这是一个很难翻译的说法,表示B或者T细胞已经在骨髓或者胸腺中发育完全并且进入血液但是还没有遇到抗原的状态.</p>
<p><img src="%E4%BA%BA%E4%BD%93%E6%B7%8B%E5%B7%B4%E7%B3%BB%E7%BB%9F.png" alt="淋巴系统的示意图" title="淋巴系统"></p>
<blockquote>
<p>淋巴细胞源自骨髓中的干细胞，并在中央淋巴器官（黄色）中分化——骨髓中的 B 细胞和胸腺中的 T 细胞。它们从这些组织迁移并通过血流输送到外周淋巴器官（蓝色）。这些包括淋巴结(lymph nodes)、脾脏(spleen)和与粘膜(mucosa)相关的淋巴组织，例如与肠道相关的扁桃体(gut-associated tonsils)、派尔氏淋巴结(Peyer’s patches)和阑尾(appendix)。外周淋巴器官是淋巴细胞被抗原激活的部位，淋巴细胞在血液和这些器官之间循环，直到遇到其特异性抗原。淋巴管将细胞外液从周围组织排出，这样一来,淋巴细胞就可以通过淋巴结进入胸导管，然后流入左锁骨下静脉。这种液体被称为淋巴液(lymph)，将树突状细胞和巨噬细胞吸收的抗原携带到淋巴结，并将淋巴细胞从淋巴结再循环回血液中。淋巴组织还与其他粘膜相关，例如支气管内壁（未显示）。</p>
</blockquote>
<h3 id="淋巴细胞在淋巴结中对抗原做出反应">淋巴细胞在淋巴结中对抗原做出反应</h3>
<p>抗原(antigen)和淋巴细胞(lymphocytes)最终在周围淋巴器官——淋巴结、脾脏和粘膜淋巴组织中相遇。成熟幼稚淋巴细胞(Mature naive lymphocytes)不断地通过这些淋巴器官再循环，而病原体抗原主要通过树突细胞从感染部位携带到这些组织。外周淋巴器官专门捕获携带抗原的树突状细胞并促进适应性免疫反应的启动。外周淋巴组织由<em>非白细胞基质细胞框架中的淋巴细胞</em>聚集组成，这些非白细胞基质细胞提供淋巴器官的<strong>基本结构组织和生存信号</strong>，以帮助维持淋巴细胞的生命。除淋巴细胞外，外周淋巴器官还含有常驻<strong>巨噬细胞和树突状细胞</strong>.</p>
<p>具体的来说,当皮肤等组织发生感染时，游离抗原和承载抗原的树突状细胞从感染部位通过<strong>传入淋巴管(afferent lymphatic vessels)<strong>进入</strong>引流淋巴结(draining lymph nodes)</strong>——外周淋巴组织，在那里它们激活抗原特异性淋巴细胞。然后，活化的淋巴细胞经历一段增殖和分化期，之后大多数通过传出淋巴管作为效应细胞离开淋巴结。它们返回到血液中，然后血液将它们带到它们将发挥作用的组织。这整个过程从识别抗原开始大约需要4-6天，这意味着对以前没有遇到过的抗原的适应性免疫反应要到感染后大约一周才会生效。还没有识别过抗原的成熟幼稚淋巴细胞((Mature naive lymphocytes))也会通过传出淋巴管返回血液，从血液中它们继续通过淋巴组织再循环，直到识别抗原或死亡.</p>
<blockquote>
<p>这里说&quot;返回&quot;是因为那些生存在淋巴结的淋巴细胞,一开始是从血液进入淋巴系统的.</p>
</blockquote>
<p><img src="%E6%B7%8B%E5%B7%B4%E5%BE%AA%E7%8E%AF.png" alt="淋巴循环" title="淋巴循环"></p>
<blockquote>
<p>淋巴和淋巴细胞通过胸导管回到了血液,幼稚淋巴细胞从血液中进入淋巴结,通过淋巴管抗原从被感染部分进入淋巴结.</p>
</blockquote>
<h2 id="淋巴器官">淋巴器官</h2>
<h3 id="淋巴结">淋巴结</h3>
<p>淋巴结是高度组织化的淋巴器官，位于淋巴系统血管的汇集点，淋巴系统是一个广泛的系统，它收集组织中的细胞外液并将其送回血液。淋巴液不断从血液中过滤产生，也可以成为淋巴,淋巴在不断产生的压力作用下从外周组织流出，由淋巴管或淋巴管输送,这些压力往往来源于肌肉运动。淋巴管中的单向阀可防止淋巴液逆流，也就是说,淋巴在身体中的流动是单方向的.</p>
<p>如上所述，传入淋巴管从组织中排出液体，将病原体和带有抗原的细胞从感染组织带到淋巴结。游离抗原通过细胞外液扩散到淋巴结，而树突状细胞则在趋化因子的吸引下主动迁移到淋巴结。同样的趋化因子还能吸引血液中的淋巴细胞，这些淋巴细胞通过穿过<strong>高内皮静脉（high endothelial venules,HEV）</strong>,这是一种的特殊血管壁,进入淋巴结。在淋巴结中，B 淋巴细胞分布在滤泡(follicles)中，滤泡构成了淋巴结的外皮层(outer cortex)。T淋巴细胞弥漫分布在皮质旁区域(paracortical areas)，也称为皮质深层或 T 细胞区。从血液迁移到淋巴结的淋巴细胞首先进入皮质旁区域(paracortical areas)，受到相同趋化因子的吸引，呈递抗原的树突状细胞和巨噬细胞也会在此聚集。通过淋巴结扩散的游离抗原会被这些树突状细胞和巨噬细胞捕获。抗原、抗原递呈细胞和幼稚 T 细胞在 T 细胞区创造了一个理想的环境，使幼稚 T 细胞能够结合其特异性抗原，从而被激活。</p>
<p>B 细胞的活化通常不仅需要与 B 细胞受体(B-cell receptor)结合的抗原(antigen)，还需要活化的辅助 T 细胞(activated helper T cells),一种效应 T 细胞,的配合。B 细胞和 T 细胞在淋巴结内的位置受其活化状态的动态调节。活化后，T 细胞和 B 细胞都会移动到滤泡和 T 细胞区的边界，在那里 T 细胞可以首先为 B 细胞提供辅助功能。一些 B 细胞滤泡包括生发中心(germinal centers)，在那里，活化的 B 细胞正在进行激烈的增殖和分化，变成浆细胞(plasma cells)。</p>
<p><img src="%E6%B7%8B%E5%B7%B4%E7%BB%93.png" alt="淋巴结" title="淋巴结"></p>
<blockquote>
<p>如图所示，淋巴结的横断面示意图左侧显示，淋巴结由最外层的皮质(outermost cortex)和内部的髓质(inner medulla)组成。皮质由外皮质的B细胞和相邻的副皮质区域组成，副皮质主要由T细胞和树突状细胞构成。当免疫反应进行时，一些被称为次级淋巴滤泡的滤泡中心会包含高度增生的B细胞区域，称为生发中心(germinal centers)。这些反应非常激烈，但随着生发中心老化而逐渐消失。从体液空间排出的淋巴通过传入淋巴管(afferent lymphatics)将组织中的抗原带到淋巴结中，这些抗原负载于吞噬作用的树突状细胞和吞噬作用的巨噬细胞中。它们直接从窦口(sinuses)迁移到淋巴结的细胞部分。淋巴通过髓质中的传出淋巴管(efferent lymphatic)离开。髓质由一系列巨噬细胞和分泌抗体的浆细胞组成，称为髓索。幼稚淋巴细胞通过特殊的毛细血管（未显示）从血液进入淋巴结，并通过传出淋巴管与淋巴一起离开。右侧的光镜照片显示了淋巴结的横断面，其中包含有生发中心的突出滤泡。放大倍数为×7。</p>
</blockquote>
<h3 id="脾脏">脾脏</h3>
<p>人类的脾脏是一个拳头大小的器官，位于胃的后方。它与淋巴系统没有直接联系，而是收集血液中的抗原，参与对血液中病原体的免疫反应。淋巴细胞通过血管进出脾脏。脾脏还收集和处理衰老的红细胞。其组织结构示意图见图。脾脏的大部分由红髓组成，是处理红细胞的场所。淋巴细胞环绕着穿过脾脏的动脉血管，形成淋巴管,也就是白髓.</p>
<p>动脉周围的淋巴细胞鞘称为动脉周围淋巴细胞鞘（periarteriolar lymphoid sheath,PALS），主要含有 T 细胞。淋巴滤泡(Lymphoid follicles)沿动脉间隔分布，主要含有 B 细胞。滤泡周围有一个被称为边缘区(marginal zone)的区域；该区域的 T 细胞很少，但巨噬细胞(macrophages)丰富，而且有一群常住的、不循环的 B 细胞，被称为边缘区 B 细胞(marginal zone B cells)。这些 B 细胞可迅速产生与细菌胶囊多糖亲和力低的抗体(low affinity to bacterial capsular polysaccharides)。这些抗体能在适应性免疫反应完全激活之前提供一定程度的保护。血液中的微生物、可溶性抗原以及抗原抗体复合物会被边缘区的巨噬细胞和未成熟树突状细胞从血液中过滤出来。就像未成熟树突状细胞从外周组织迁移到淋巴结的 T 细胞区一样，脾脏边缘区的树突状细胞在吸收抗原并被激活后，也会迁移到 T 细胞区。</p>
<p><img src="%E8%84%BE%E8%84%8F.png" alt="脾脏" title="脾脏"></p>
<blockquote>
<p>左上方的示意图显示脾脏由红髓（粉色区域）和淋巴样白髓交替组成，红髓是红细胞讲解的场所。人体脾脏的一个小部分放大图（右上方）显示白髓（黄色和蓝色）在中央动脉周围的离散区域的排列方式。大部分白髓在横截面中显示，有两个部分为纵切面。此图示下方的两个示意图显示了一横截面（中心下方）和一纵切面（右下方）的白髓放大图。中央动脉的周围是动脉周围淋巴鞘（periarteriolar lymphoid sheath,PAlS），由T细胞组成。淋巴细胞和负载抗原的树突状细胞在此处聚集。滤泡(follicles)主要由B细胞组成；在二级滤泡中(secondary follicles)，用B细胞冠(B-cell corona)围绕着生发中心(germinal center)。滤泡被所谓的边缘区淋巴细胞包围。在每个白髓区域，携带淋巴细胞和抗原的血液从小梁动脉流入中央动脉。从中央动脉出来的较小血管最终扩散，最终终止于人体脾脏中被称为髓外区（perifollicular zone,PFZ）的特殊区域，该区域环绕着每个边缘区。细胞和抗原然后通过髓外区的血液充填的开放空间进入白髓。左下方的光镜照片显示了成熟B细胞的人脾白髓的横截面免疫染色。滤泡和PAlS都被髓外区环绕。滤泡动脉出现在PAlS中（底部箭头），穿过滤泡，穿过边缘区，并进入髓外区（上部箭头）。Co，滤泡B细胞冠；gC，生发中心；mZ，边缘区；rP，红髓；箭头，中央动脉。</p>
</blockquote>
<h3 id="粘膜中的淋巴器官">粘膜中的淋巴器官</h3>
<p>大多数病原体通过粘膜表面进入体内，同时这些粘膜还会接触到空气、食物和体内自然微生物群等大量其他潜在抗原。粘膜表面由一个被称为粘膜免疫系统(mucosal immune system)或粘膜相关淋巴组织（mucosa-associated lymphoid tissues,MALT）的广泛组织系统保护。整个粘膜免疫系统估计含有与全身其他部分一样多的淋巴细胞，它们形成一组特殊的细胞，遵循与其他外周淋巴器官中的细胞略有不同的再循环规则。</p>
<p>肠相关淋巴组织（gut-associated lymphoid tissues,GALT）包括扁桃体(tonsil)、腺样体(adenoid)、阑尾(appendix)和小肠中的特殊结构—派氏斑(Peyer’s patches)，它从胃肠道上皮表面收集抗原。Peyer氏斑是一种重要且高度有序的组织，抗原由称为微小褶皱细胞或者M细胞(microfold or M cells)的特殊上皮细胞(epithelial cells)收集。淋巴细胞形成滤泡，包括由大量B淋巴细胞和环绕的少量T淋巴细胞构成的大中央圆顶(large central dome)。Peyer氏斑内的树突状细胞向T淋巴细胞传递抗原。淋巴细胞从血液进入Peyer氏斑，并通过外流淋巴管离开。在Peyer氏斑中产生的效应淋巴细胞通过淋巴系统进入血液循环，并重新分散到粘膜组织中执行它们的效应作用。</p>
<p>呼吸道和其他粘膜中存在类似但更弥漫的淋巴细胞聚集体：鼻相关淋巴组织（nasal-associated lymphoid tissue,NALT）和支气管相关淋巴组织（bronchus-associated lymphoid tissue,BALT）存在于呼吸道中。类似Peyer氏斑块，这些粘膜淋巴组织也被M细胞覆盖，通过这些M细胞，吸入的微生物和陷入呼吸道黏液覆盖物中的抗原可以通过。</p>
<p>因为它们参与启动适应性免疫反应，所以外周淋巴组织不是静态结构，而是变化很大，这主要取决于是否存在感染.弥漫性粘膜淋巴组织(diffuse mucosal lymphoid tissues)可能会因感染而出现，然后消失，而有组织的组织结构(architecture of the organized tissues)在感染期间会以更明确的方式发生变化。例如，随着B淋巴细胞增殖形成生发中心，淋巴结的B细胞滤泡扩张，整个淋巴结增大，这种现象被称为腺体肿胀(swollen glands)。</p>
<p><img src="%E8%82%A0%E9%81%93%E4%B8%AD%E7%9A%84%E6%B4%BE%E6%B0%8F%E7%BB%93.png" alt="派氏结" title="Peyer's patches"></p>
<blockquote>
<p>左图所示，派尔氏淋巴集结包含许多具有生发中心(germinal centers)的 B 细胞滤泡(B-cell follicles)。卵泡之间的区域被 T 细胞占据，因此被称为 T 细胞依赖区域(t-cell dependent areas)。表面上皮和滤泡之间的层称为上皮下圆顶(subepithelial dome)，富含树突状细胞、T 细胞和 B 细胞。派尔氏淋巴集结没有传入淋巴管，抗原直接从肠道穿过由所谓的微褶皱 (M) 细胞组成的特殊上皮进入。尽管该组织看起来与其他淋巴器官非常不同，但基本的划分仍然保留。与淋巴结中一样，淋巴细胞从血液穿过高内皮微静脉壁（未显示）进入派尔氏淋巴结，并通过传出淋巴管离开。 a 图中的光学显微照片显示了小鼠肠壁派尔氏淋巴结的切片。可以看到派尔氏集结位于上皮组织下方。 Gc，生发中心； TDA，T 细胞依赖区域(t-cell dependent areas)。图b是图a中框出的滤泡相关上皮的扫描电子显微照片，显示了M细胞，其缺乏正常上皮细胞上存在的微绒毛(microvilli)和粘液层(mucus layer)。每个 M 细胞表现为上皮表面的凹陷区域。图 c 是图 b 中方框区域的更高放大倍数视图，显示了 M 单元的特征性褶皱表面。 M 细胞是许多病原体和其他颗粒的进入门户。图a，苏木精和伊红染色，放大倍数×100；图 b ，×5000；图 c，×23,000。</p>
</blockquote>
]]></content>
      <categories>
        <category>生物</category>
        <category>免疫生物学</category>
      </categories>
      <tags>
        <tag>免疫生物学</tag>
        <tag>淋巴</tag>
        <tag>免疫反应</tag>
        <tag>病原体</tag>
      </tags>
  </entry>
  <entry>
    <title>关于butterfly主题的相关说明</title>
    <url>/blog/2023/09/04/%E5%85%B3%E4%BA%8Ebutterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="文章的基础设置">文章的基础设置</h2>
<p>当我们使用<code>hexo new &quot;关于butterfly主题的相关说明&quot;</code>建立了新的<code>.md</code>文件和对应的文件夹之后,在<code>.md</code>的开头会为我们自动生成一些基础的设置,其形式如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 关于butterfly主题的相关说明</span><br><span class="line">date: y-m-d h:m:s</span><br><span class="line">tags:</span><br><span class="line"><span class="code">    -</span></span><br></pre></td></tr></table></figure>
<p>但是,依然有一些设置是需要自己添加的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:  # 文章的题目</span><br><span class="line">date:   # 文章的建立的日期</span><br><span class="line">updated:    # 文章的最近的更新的日期</span><br><span class="line">tags:   # 文章的标签</span><br><span class="line">categories: # 文章的分类</span><br><span class="line">keywords:   # 文章的关键字</span><br><span class="line">description:    # 文章的描述</span><br><span class="line">top<span class="emphasis">_img:    # 文章页面顶部的图片,设置这个不会影响缩略图,但是我喜欢叫二者统一</span></span><br><span class="line"><span class="emphasis">cover:  # 文章在主页的缩略图</span></span><br><span class="line"><span class="emphasis">copyright:  # 显示文章的版权,默认使用post_</span>copyright中的enable的设置</span><br><span class="line">copyright<span class="emphasis">_author:   # 本篇文章的作者,可能和博主不是一个人,不过我这里似乎没有这个问题</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:  # 文章作者的连接</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:  # 文章版权模块的文章连接</span><br><span class="line"><span class="section">copyright<span class="emphasis">_info: # 文章版权模块的版权声明</span></span></span><br><span class="line"><span class="emphasis"><span class="section">---</span></span></span><br></pre></td></tr></table></figure>
<p>事实上,依然有很多其他设置可以调整,但是我喜欢保持每个页面的统一,所以都使用了默认的模式.</p>
<h2 id="建立新文章和建立新页面">建立新文章和建立新页面</h2>
<p>文章和页面是两个不同的东西,文章就是你现在看到的东西,而页面是<em>分类,标签,友联</em>这样的东西.创建文章和页面采用的是不同的命令.</p>
<h3 id="建立文章">建立文章</h3>
<p>在<code>_post</code>文件夹下,打开<code>git</code>,输入下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章的名字&quot;</span>   <span class="comment"># 采用这样的方法,就实现了文章的建立</span></span><br></pre></td></tr></table></figure>
<h3 id="建立新页面">建立新页面</h3>
<p>在hexo博客的根目录,也就是<code>blog</code>目录,打开<code>git</code>,输入下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories/links/tags     <span class="comment"># 这样就建立了分类/友链/标签页面</span></span><br></pre></td></tr></table></figure>
<p>对不同的新页面会有一些不同的细节设置,具体可以参考<a href="https://butterfly.js.org/posts/dc584b87/#%E6%A8%99%E7%B1%A4%E9%A0%81">帮助文档</a></p>
<h2 id="标签外挂">标签外挂</h2>
<p>这隔功能我第一次见的时候就感觉很神奇,但是一直没有机会好好的研究,接着这次机会好好的琢磨一下<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%8C%89%E9%88%95%E6%8E%92%E5%BA%8F">帮助文档</a>给出了两种使用方法,这里一并介绍.</p>
<div class="note info simple"><p>标签外挂是Hexo独有的功能，并不是标准的Markdown格式。</p>
<p>以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p>
</div>
<div class="note warning simple"><p>标签外挂虽然能为主题带来一些额外的功能和UI方面的强化，但是，标签外挂也有明显的限制，使用时请留意。</p>
</div>
<h3 id="用法一">用法一</h3>
<p>这种方法采用了模板中给出的标记,使用方法如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>[可选]标识,不同的标识有着不同的颜色: <em>default / primary / success / info / warning / danger</em></td>
</tr>
<tr>
<td>no-icon</td>
<td>[可选]不显示icon</td>
</tr>
<tr>
<td>style</td>
<td>[可选]使用新的style覆盖配置中的默认style</td>
</tr>
</tbody>
</table>
<h3 id="用法二">用法二</h3>
<p>事实上,这个和上一个没有什么本质区别,只是用户可以根据自己的喜欢选择合适的<code>icon</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>【可选】顔色<em>default / blue / pink / red / purple / orange / green</em></td>
</tr>
<tr>
<td>no-icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>[可选]可以覆盖配置中的 style(simple/modern/flat/disabled)</td>
</tr>
<tr>
<td>fontawesome 图标</td>
<td>'fas fa-bullhorn’形如这样的格式进行使用,具体可以参考官方<a href="https://fontawesome.com/v4/icons/">介绍</a></td>
</tr>
</tbody>
</table>
<h2 id="tag-hide">tag-hide</h2>
<p>我感觉这是一个很帅的功能,但是我自己应该用不到,所以只是贴出<a href="%5Bhttps://butte%5D(https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A)">官方的介绍</a></p>
<h2 id="mermaid">mermaid</h2>
<p>使用<a href="http://mermaid.js.org/#/">mermaid标签</a>可以绘制Flowchart(流程图)/Sequence diagram(时序图)/Class Diagram(类别图)/State Diagram(状态图)/Gantt(甘特图)和Pie Chart(圆形图).</p>
<p>首先需要在主题配置文件中做一些修改:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure>
<p>然后是一些案例:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
<p>这个是一般的使用范式</p>
<h3 id="案例">案例</h3>
<p>下面是一个流程图(Flowchart)的案例以及对应的代码:</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
  </pre></div>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD;</span><br><span class="line"><span class="code">    A--&gt;B;</span></span><br><span class="line"><span class="code">    A--&gt;C;</span></span><br><span class="line"><span class="code">    B--&gt;D;</span></span><br><span class="line"><span class="code">    C--&gt;D;</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Tabs">Tabs</h2>
<p>同样是一个十分酷炫的功能,可以实现这样的效果:</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
  </pre></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD;</span><br><span class="line"><span class="code">    A--&gt;B;</span></span><br><span class="line"><span class="code">    A--&gt;C;</span></span><br><span class="line"><span class="code">    B--&gt;D;</span></span><br><span class="line"><span class="code">    C--&gt;D;</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>虽然<a href="https://butterfly.js.org/posts/4aa8abbe/#Tabs">文档</a>给出了4种不同的使用方法,但是对于我只有<em>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</em>这个选项是有用的:</p>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fa fa-code"></i>代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 代码 @fa fa-code --&gt;</span><br><span class="line"><span class="strong">****</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="inlineImg">inlineImg</h2>
<p>文章中的图片在没有特别说明的情况下都是<code>块级元素</code>但是有时候我们会需要<code>内联元素</code>这个时候就需要使用这个标签外挂.</p>
<p><img src="cover.jpg" alt="块级元素" title="这是块级元素的封面"></p>
<p>这里是内联元素的封面<img class="inline-img" src="cover.jpg" style="height:150px"></p>
<p>这里是对应的代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">块级元素</span>](<span class="link">cover.jpg &quot;这是块级元素的封面&quot;</span>)</span><br><span class="line"></span><br><span class="line">这里是内联元素的封面&#123;% inlineImg cover.jpg 150px %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语">结语</h2>
<p>以上就是我觉得未来可能会用到的功能,如果以后发现上面的内容不够用,会把新使用的功能补充上来.</p>
]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>利用git实现本地文件和远程仓库的同步</title>
    <url>/blog/2023/08/28/%E5%88%A9%E7%94%A8git%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="我的场景—本地文件夹有内容">我的场景—本地文件夹有内容</h2>
<h3 id="步骤一-创建一个新的GitHub仓库">步骤一:创建一个新的GitHub仓库</h3>
<ol>
<li>GitHub网站上登陆账号</li>
<li>点击右上角加号图标,选择&quot;New repository&quot;<br>
<img src="2023-08-28-07-28-52.png" alt="建立新仓库"></li>
<li>输入仓库名称,描述,并设置为公有或者私有</li>
</ol>
<blockquote>
<p>有一点值得指出,这里建立的仓库最好先不要建立&quot;BEADME&quot;和许可证文件,具体原因后文再说</p>
</blockquote>
<h2 id="步骤二-初始化本地文件夹为Git仓库">步骤二:初始化本地文件夹为Git仓库</h2>
<p>在本地文件夹中右键打开<strong>Git Brash</strong></p>
<p>或者可以在任何地方打开<strong>Git Brash</strong>,然后使用<code>cd D:\xxx\xxx\xxx</code>进入本地文件</p>
<p>然后初始化Git仓库并且把它连接到远程的GitHub仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init    <span class="comment">#   这个命令运行之后会在根目录中看到一个&quot;.git&quot;文件夹</span></span><br></pre></td></tr></table></figure>
<p>然后添加文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .   <span class="comment">#   把本地的文件都先加载到缓冲区</span></span><br></pre></td></tr></table></figure>
<p>然后设置本次操作的说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;你的操作说明,比如:第一次上传本地文件&quot;</span></span><br></pre></td></tr></table></figure>
<p>选择分支,这里要和GitHub中的对应上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -M main  <span class="comment"># 也可以是是master</span></span><br></pre></td></tr></table></figure>
<p>如果不小心搞错了分支,可以使用一下命令换回:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m master main   <span class="comment"># 从分支master换到main</span></span><br></pre></td></tr></table></figure>
<p>然后连接远程仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/&lt;GitHub用户名&gt;/&lt;仓库名称&gt;.git</span><br></pre></td></tr></table></figure>
<p>这里,因为我们在本地有文件,并且我一开始犯了一个错误,就是建立了<strong>README</strong>和许可证文件,所以操作会比较麻烦.</p>
<p>首先,把远端仓库拉取到本地,并且允许合并不相关的历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main --allow-unrelated-histories  </span><br></pre></td></tr></table></figure>
<p>然后,把本地的变更推送到远程仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
<p>这样的操作会导致合并的历史不太整洁,不过我们这里还只是创建,所以影响不大.同时,最好关掉你的<strong>VPN</strong>,如果开启可能会出现&quot;<code>fatal: unable to access 'https://github.com/a-green-hand-jack/Benign-Overfitting.git/': Recv failure: C onnection was reset</code>&quot;这样的报错,这说明你在同步的时候遇到了一些网络问题.</p>
<p><img src="2023-08-28-08-04-38.png" alt="错误的网络"></p>
<p>很好,如果一切顺利,这个时候你就应该实现了本地和远程的同步!</p>
<h2 id="使用ssh协议推送和拉取代码">使用ssh协议推送和拉取代码</h2>
<p>正如前文所述的那样,<code>pull</code>和<code>push</code>的时候,为了网络的稳定,最好关闭<strong>VPN</strong>.但是有的时候,登录GitHub网页又需要使用<strong>VPN</strong>,如果反复的关闭,连接就很麻烦.这个时候可以考虑使用<strong>ssh协议</strong>,这可以提高推送和拉取时的稳定性.</p>
<h3 id="假设已经有了一个ssh密钥">假设已经有了一个ssh密钥</h3>
<p>在git中切换到ssh协议进行操作,首先验证一下是否能够连接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>然后,使用<code>git remote</code>修改远程仓库的URL:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure>
<p>最后,只要像之前一样的<code>pull</code>和<code>push</code>就好了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
<h3 id="检查之前建立的密钥">检查之前建立的密钥</h3>
<p>首先检查一下现有的密钥,在<code>git</code>里面:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>这样会列出<code>C:\Users\XXX\.ssh</code>文件中的所有的密钥</p>
<p>然后,我们可以检查一下现有的公钥的内容,如果你的<code>git</code>打开的位置不在<code>C:\Users\XXX\.ssh</code>文件夹下,请先转到对应的位置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:Users/XXX/.ssh</span><br></pre></td></tr></table></figure>
<p>然后,就可以打开公钥查看了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>请注意，SSH 密钥是敏感信息，私钥应当保密并妥善保存。不要在不受信任的地方公开或共享您的私钥。如果您怀疑私钥可能已经泄露，应当立即生成新的密钥对。</p>
<h3 id="生成新的密钥">生成新的密钥</h3>
<p>在git中输入以下命令来生成新的SSH密钥对:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>这将生成一个新的 RSA 密钥对，默认情况下保存在 ~/.ssh/id_rsa（私钥）和 ~/.ssh/id_rsa.pub(公钥)</p>
<p>然后输入以下内容来查看生成的公钥的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>复制生成的公钥内容，确保复制的内容是完整的公钥格式。</p>
<p>将公钥内容粘贴到您希望使用 SSH 密钥进行身份验证的地方，例如 GitHub 或其他远程服务器。</p>
<p>请注意，生成新的密钥对会替代之前的密钥，因此在更新密钥时，您需要更新相应的授权设置，例如 GitHub 上的 SSH 密钥设置.</p>
<h2 id="忽略程序运行中的大文件">忽略程序运行中的大文件</h2>
<p>有时候,我们编辑的虽然是<code>.py</code>或者<code>.ipynb</code>之类的文本文件,但是文件运行的过程中会产生一些很大的文件,这些部分有时候是不用上传的,我们有好几种方法来忽略它</p>
<h3 id="在-gitignore-文件中排除文件">在 <code>.gitignore</code> 文件中排除文件</h3>
<p>在您的项目根目录下创建一个名为 <code>.gitignore </code>的文件，然后在文件中添加一行 <code>cifar-10-python.tar.gz</code>这将告诉 Git 忽略这个文件，不将其纳入版本控制.</p>
<p>如果你需要忽略位于深层文件夹内的文件，可以在 .gitignore 文件中使用相对路径或通配符来指定这些文件。以下是一些示例：</p>
<ol>
<li>相对路径：</li>
</ol>
<p>假设你的大文件位于 <code>path/to/your/large_file.txt</code>，而你希望忽略它，可以在 <code>.gitignore</code> 文件中添加相对路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_file.txt</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通配符：</li>
</ol>
<p>如果你需要忽略某个文件夹内的所有内容，可以使用通配符 *。例如，如果你希望忽略 path/to/your/large_folder 内的所有文件，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/*</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>递归通配符：</li>
</ol>
<p>如果你需要递归地忽略某个文件夹及其子文件夹内的所有内容，可以使用双星号 **。例如，如果你希望忽略 path/to/your/large_folder 及其子文件夹内的所有内容，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/**</span><br></pre></td></tr></table></figure>
<p>这会将 <code>large_folder</code> 内的所有内容及其子文件夹都排除在版本控制之外.</p>
<p>使用这些方法，你可以在 <code>.gitignore</code> 文件中指定你想要忽略的深层文件夹内的文件。Git 将会自动忽略这些文件，确保它们不会被纳入版本控制.</p>
<h3 id="说明文件结构">说明文件结构</h3>
<p>在 <code>.gitignore</code> 文件中，使用的是相对于根目录的相对路径。所以，如果你的项目根目录是 <code>D:/XXX/YYY/ZZZ</code>，那么在 <code>.gitignore</code> 文件中指定 <code>path/to/your/large_folder</code>实际上是指定相对于根目录的路径。</p>
<p>具体而言，如果你的项目结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">D</span>:<span class="regexp">/XXX/</span><span class="variable constant_">YYY</span>/<span class="variable constant_">ZZZ</span>/</span><br><span class="line">  ├── path/</span><br><span class="line">  │    └── to/</span><br><span class="line">  │        └── your/</span><br><span class="line">  │            └── large_folder/</span><br><span class="line">  │                ├── large_file1.<span class="property">txt</span></span><br><span class="line">  │                ├── large_file2.<span class="property">txt</span></span><br><span class="line">  │                └── ...</span><br><span class="line">  ├── other_folder/</span><br><span class="line">  │    └── ...</span><br><span class="line">  ├── ...</span><br><span class="line">  └── .<span class="property">gitignore</span></span><br></pre></td></tr></table></figure>
<p>那么在 <code>.gitignore</code> 文件中的路径应该是相对于根目录的路径，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/</span><br></pre></td></tr></table></figure>
<p>这将会忽略 <code>large_folder</code> 及其内部的所有文件</p>
]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo和Github搭建个人博客</title>
    <url>/blog/2023/08/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-md/</url>
    <content><![CDATA[<h2 id="环境配置">环境配置</h2>
<h3 id="注意事项">注意事项</h3>
<p>$ a=b+1+\sqrt{2}$</p>
<ol>
<li>输入代码时候,切换为英文输入法</li>
<li>文中的<strong>用户名</strong>和<strong>邮箱</strong>替换为自己的GitHub的<strong>账户名</strong>和绑定的<strong>邮箱</strong></li>
<li>使用<strong>Git Bash</strong>而不是Git GUI</li>
<li>以Windows10系统为例</li>
<li>假设已经拥有GitHub账户</li>
<li>博客根目录就是下载hexo的地址</li>
<li>在不熟悉操作的前提下请不要跳步</li>
</ol>
<h3 id="安装Git和Node-js">安装Git和Node.js</h3>
<p>首先在<a href="https://git-scm.com/downloads">Git</a>中下载和自己电脑系统相适应的版本;然后再<a href="https://nodejs.org/zh-cn">Nodes</a>中下载Nodes.js,这里建议使用<em>长期维护版</em>.<br>
下载之后的安装一直点击<code>next</code>就好.</p>
<p>安装完成之后,在cmd中输入命令查看版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="2023-08-25-01-50-52.png" alt="检查版本"></p>
<h2 id="配置GitHub">配置GitHub</h2>
<h3 id="连接GitHub">连接GitHub</h3>
<p>首先,在博客根目录中右键打开<code>git bash</code>,输入命令设置用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>
<p>然后,将Git绑定远程GitHub账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -keygen -t rsa -C <span class="string">&quot;GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行了上述指令之后,按下三个回车,然后复制<code>C:\Users\user-name\.ssh</code>中的<code>id_rsa.pub</code>中的内容.注意这里的<em>user-name</em>就是计算机用户的名字,每个人的不一样.</p>
<p>然后,进入GitHub个人账号,Setting-&gt;SSH and GPGkeys -&gt; New SSH key</p>
<p><img src="2023-08-25-02-04-44.png" alt="SSH and GPGkeys"><br>
<img src="2023-08-25-02-05-35.png" alt="New SSH key"></p>
<p>最后验证连接,在博客根目录下打开<em>Git Bash</em>输入<code>ssh -T git@github.com</code>,会得到<code>Hi user.name! You've successfully authenticated, but GitHub does not provide shell access. </code>这样的回复,就说明连接已经成功了.</p>
<h3 id="建立GitHub-Pages-仓库">建立GitHub Pages 仓库</h3>
<p>在主页面点击头像,进入<em>我的仓库</em>,然后在顶部点击<em>Create new</em>建立一个新的仓库,在Repository name <a href="http://xn--user-name-pl6ni7zuz8q.github.io">中输入user-name.github.io</a>,勾选<em>Initialize this repository with a README</em>,然后点击<em>Create repository</em></p>
<h2 id="Hexo配置">Hexo配置</h2>
<h3 id="Hexo博客程序的本地安装">Hexo博客程序的本地安装</h3>
<p>这个建立在Node已经成功安装的基础上,首先使用<code>npm</code>安装Hexo,这里建议使用<strong>魔法</strong>,不然下载会很慢.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="Hexo初始化和本地预览">Hexo初始化和本地预览</h3>
<p>首先在<em>cmd</em>中输入以下命令,实现初始化和组件安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init <span class="comment"># 初始化</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure>
<p>然后在<em>git bash</em>中输入命令,启动本地服务器并预览:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  # 生成页面</span><br><span class="line">hexo s  # 启动预览</span><br></pre></td></tr></table></figure>
<p>访问<code>http://localhost:4000</code>,出现了Hexo默认页面,说明本地博客安装成功</p>
<h3 id="博客的目录结构">博客的目录结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.landscape.yml   </span><br><span class="line">├── _config.yml   #全局配置文件，比如网站名称，副标题，秒速，作者，语言等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html.</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds   # 骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当hexo生成新博客的时候，会用这里面的模版进行初始化.</span><br><span class="line">├── source  # 这个文件夹下面存放的是网站的markdown源文件，里面有一个_post文件夹，所有的.md博客文件都会存放在这个文件夹下。现在有一个hello-world.md文件</span><br><span class="line">└── themes # 网站主题目录，hexo有非常丰富的主题支持，主题目录会存放在这个目录下面。更多的主题参见：https://hexo.io/themes/</span><br></pre></td></tr></table></figure>
<h3 id="部署Hexo到GitHub-Pages">部署Hexo到GitHub Pages</h3>
<p>首先,安装hexo-deployer-git:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后修改<code>_config.yml</code>文件末尾部分,结果如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>    <span class="comment"># 这里要求user-name.github.io中的主要分支是master</span></span><br></pre></td></tr></table></figure>
<p>然后,使用在<em>git bash</em>中使用<code>hexo d</code>把网站上传并部署到GitHub Pages.</p>
<p>然后访问<code>https://user-name.github.io</code>就可以看到自己的HExo博客了, 不过这里还没有自己写的内容</p>
<h2 id="年轻人的第一篇博客">年轻人的第一篇博客</h2>
<h3 id="建立书写博文">建立书写博文</h3>
<p>在<code>source</code>文件夹中,使用<code>hexo new &quot;first post&quot;</code>会建立一个<em>first <a href="http://post.md">post.md</a></em>文件,然后使用vscode之类的文本编辑器就可以以Markdown语言书写自己的博客文章了.</p>
<h3 id="另一种建立方法">另一种建立方法</h3>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tutorial:基于Hexo和Github搭建个人博客</span><br><span class="line">date: 2022-08-25 14:07:06</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> other</span><br><span class="line">keywords:</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="bullet">-</span> github</span><br><span class="line"><span class="section">- blog</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>
<h3 id="部署发布">部署发布</h3>
<p>依次使用<em>git bash</em>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  # 生成页面</span><br><span class="line">hexo d  # 部署发布</span><br></pre></td></tr></table></figure>
<h2 id="其他问题">其他问题</h2>
<h3 id="更换主题">更换主题</h3>
<p>比如要下载一款经典的<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题,只要在<code>Blog</code>根目录下打开<em>git bash</em>,然后输入<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code>就实现了下载.<br>
然后在<code>_config.yml</code>文件中修改配置<code>theme: butterfly</code><br>
最后清除缓存<code>hexo clean</code>,再重新建立<code>hexo g</code></p>
<h3 id="插入图片">插入图片</h3>
<h4 id="下载插件">下载插件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>在<code>~\blog\node_modules\hexo-asset-image</code>中的<code>index.js</code>中的第58行把</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br></pre></td></tr></table></figure>
<p>修正为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, src);</span><br></pre></td></tr></table></figure>
<h4 id="修改配置文件">修改配置文件</h4>
<p>在_config.yml配置文件将<code>post_asset_folder:false</code>改成<code>true</code><br>
之后使用<code>hexo new &quot;blog name&quot;</code>的时候会同时生成同名文件夹用来存放资源(将所有图片放在这个文件夹内)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片的文字描述</span>](<span class="link">/如何使用Hexo和Github搭建个人博客-md/2023-08-25-02-47-12.png &quot;图片的名字&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="2023-08-25-02-47-12.png" alt="插入图片"></p>
<h4 id="利用VScode插件快速粘贴图片">利用VScode插件快速粘贴图片</h4>
<p>下载插件Paste Image ,在剪贴板有图片的情况下,按下<code>ctrl+alt+v</code>就会把图片插入到光标所在位置.<br>
但是这个时候图片存在的位置不对,在编译之前把它们放到正确的文件夹中.</p>
<h3 id="npm书写规范">npm书写规范</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo搭建个人博客</span><br><span class="line"><span class="section">#title:[空格]标题    #空格必须有</span></span><br><span class="line"><span class="section">#title: “标题” #如果标题中有双引号要用中文双引号</span></span><br><span class="line">date: 2021-11-15 22:16:30</span><br><span class="line"><span class="section">#添加多个tags的规范，注意 -[空格]Hexo #同样要有空格</span></span><br><span class="line">tags:   # 表签</span><br><span class="line"><span class="bullet">-</span> Hexo</span><br><span class="line"><span class="bullet">-</span> HTML</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="section">  - [技术分享, 博客制作]</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h3 id="插入视频连接">插入视频连接</h3>
<p>要在你的页面中播放Bilibili视频，而非直接跳转到Bilibili网站，你可以使用特定的播放器插件或工具来实现.在这种情况下，你可以尝试使用Bilibili的官方播放器插件“bilibili-player”，或者使用其他类似的第三方播放器插件来嵌入视频.</p>
<p>以下是一种使用bilibili-player插件的示例方法：</p>
<p>首先，确保你已经引入了bilibili-player插件的必要脚本和样式文件。然后，将以下代码插入到你想要显示视频的位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili-player&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili-player-video&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://player.bilibili.com/player.html?bvid=BV1FV4y1e7fB&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;autoplay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>确保将视频的BV号（bvid）替换为你想要嵌入的Bilibili视频的BV号.样，视频就会在你的页面中显示，并且只有在点击时才会跳转到Bilibili网站.</p>
<p>要调整嵌入视频的页面大小，你可以修改iframe元素的width和height属性值.通过调整这些值，你可以控制视频播放区域的宽度和高度:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://player.bilibili.com/player.html?bvid=BV1FV4y1e7fB&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;autoplay&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>    # <span class="attr">宽度是100</span>%</span></span><br><span class="line"><span class="tag"><span class="attr">height</span>=<span class="string">&quot;400px&quot;</span>&gt;</span> # 高度是400像素</span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
