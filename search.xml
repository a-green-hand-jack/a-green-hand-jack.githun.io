<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Transformer学习记录</title>
    <url>/blog/2023/09/21/Transformer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p><a href="http://arxiv.org/abs/1706.03762">Attention is All You Need</a>是transformer的开山之作。论文相关的Tensorflow的代码可以从<a href="https://github.com/tensorflow/tensor2tensor">GitHub</a>获取，当然也有很多人对它进行了<a href="https://github.com/huggingface/transformers">二次开发</a>.</p>
<p>文中，我试图把模型简化一点，逐一介绍里面的核心概念，希望让初学者也能轻易理解.</p>
<h2 id="机器翻译">机器翻译</h2>
<p><img src="%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91.png" alt="机器翻译" title="机器翻译"></p>
<p>transformer一开始提出主要是用于翻译工作,所以我们不妨从翻译的原理开始认识它.</p>
<p>首先,我们可以观察到翻译是由两部分<strong>encoder</strong>和<strong>decoder</strong>组成的;这里<strong>encoder</strong>会吸收需要被翻译的句子,也就是<em>Machine Learning</em>而<strong>decoder</strong>会输出对应的<em>机器学习</em></p>
<p>具体的讲,整个翻译工作分为以下几步:</p>
<h3 id="语句处理">语句处理</h3>
<p>对于一段话而言,词语本身的意思和词语之间的相对位置同样重要.所以翻译器会首先通过<strong>token embeddings</strong>获取每一个词的本身的意思对应的向量和词语在句子位置中对应的向量;并且把两者加起来.这样每一个词就可以用一个向量同时表示意思和位置.对应的,一个句子就可以用一个矩阵表达.</p>
<h3 id="处理句子矩阵">处理句子矩阵</h3>
<p>然后,我们把刚刚得到的句子的向量矩阵$X$传入<strong>encoder</strong>中,随后会输出一个含有句子所有信息的编码句子$C$.$X$和$C$形状完全相同都是$n\times d$,这里的$n$表示句子中含有的单词的数量,$d$表示一个单词的向量维度&lt;文中采用$d=512$&gt;.</p>
<h3 id="翻译">翻译</h3>
<p>现在我们把<strong>encoder</strong>输出的$C$传入<strong>decoder</strong>中,也就是把需要被翻译的语句的信息传入.同时传入一个特殊符号&quot;$“,它表示一句话的开始,随后<strong>decoder</strong>就会根据$C$和”$“输出第一个汉字&quot;<strong>机</strong>”.</p>
<p>然后,“<strong>$+机</strong>&quot;会代替原来的$的位置作为输入和$C$经过<strong>decoder</strong>输出&quot;<strong>器</strong>”.</p>
<p>这样周而复始,直到输出另一个特殊的代表句子结束的符号&quot;#&quot;.</p>
<p>下面,我们就具体介绍transformer是怎么实现这个过程的.</p>
<h3 id="Transformer的整体架构">Transformer的整体架构</h3>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>可以看出,transformer的和刚才的翻译器在形式上是类似的,下面就具体展开说说每一部分是在做什么.</p>
<h2 id="Transformer的输入">Transformer的输入</h2>
<h3 id="input-Embedding">input Embedding</h3>
<p>Inputs,也就是我们输入需要被翻译的文字,在通过embedding vector之后会映射到一个高维的空间中,也就是说词的&quot;feature&quot;被提取了出来,并且被放在了一个矩阵中,不妨称之为<strong>词义矩阵</strong></p>
<h3 id="positional-Encoding">positional Encoding</h3>
<p>获得句子中的每一个单词的位置信息,同样形成了一个矩阵,不妨称之为<strong>位置矩阵</strong>.然后把词义矩阵和位置矩阵相加,得到的就是encoder的输入.</p>
<p>具体的位置矩阵的算法有很多,这里介绍一种比较简单的方法:</p>
<p>$$<br>
PE_{(pos,2i)}=\sin(\frac{pos}{10000^{\frac{2i}{d}}}),<br>
PE_{(pos,2i+1)}=\cos(\frac{pos}{10000^{\frac{2i}{d}}})<br>
$$</p>
<p>这里的$PE$表示词的位置信息;$pos$表示词在句子中的位置;$d$表示词的维度,也就是词的&quot;feature&quot;所需要的度量的数量;$2i$就是偶数维度,$2i+1$就是奇数维度.采用这种计算方法及足够简单,又很好的满足了几个条件:</p>
<ol>
<li>保证了PE和词的大小一样,也就是词义矩阵和位置矩阵大小一样</li>
<li>PE可以适应验证集中出现比训练集中句子更长的情况</li>
<li>有利于获得相对位置的信息,比如两个单词相距$k$,知道一个就可以快速得到另一个:$\sin(pos+k)=\sin(pos)\cos(k)+\cos(pos)\sin(k),cos(pos+k)=\cos(pos)\cos(k)-\sin(pos)\sin(k)$</li>
</ol>
<h3 id="进入encoder">进入encoder</h3>
<p>把input embedding 和positional embedding相加就能得到表示句子的矩阵$X$,它随后进入了encoder</p>
<h2 id="Self-Attention-自注意力机制">Self-Attention(自注意力机制)</h2>
<p>在进入encoder之前,有必要先介绍以下自注意力机制,这也是transformer的精髓所在,再看一眼整体架构.</p>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>请注意那些<strong>浅橙色</strong>的色块,这里的<strong>Self-Attention</strong>正是我们接下来要关注的,而且这个结构在encoder和decoder中是一样的.至于&quot;Multi-Head Attention&quot;和&quot;Masked Multi-Head Attention&quot;本质上也是一样的,只是多了一些修饰.</p>
<h3 id="Self-Attention的结构">Self-Attention的结构</h3>
<p>首先看一个简单的例子了解什么是<strong>注意力</strong>.如下图,所谓注意力就是一个词和另一个词的联系的紧密程度.这里<strong>绿色的The</strong>就是我们要考察的的对象,我们想知道它和句子中的其他的联系的紧密程度如何,所以我们用<strong>The</strong>的表示向量$\vec x_{the}$和句子中其他单词的表示向量$\vec x_{others}$做内积.然后使用softmax进行归一化,也就是得到<strong>The</strong>和其他词语之间的关系的打分.</p>
<p>然后,我们利用这个’打分系统’对句子中的每一个词打分并相加,就得到了<strong>The</strong>在整个句子中的占有的<strong>注意力</strong></p>
<p>事实上,我们可以看出,由于&quot;The,weather,is,nice,today&quot;中的每一个词都要有相同的操作,所以可以把整个过程看作是矩阵乘法,也就是:</p>
<p>$$<br>
Attention=softmax(X\cdot X^{T})\cdot X<br>
$$</p>
<p>这里,输入和输出的矩阵的形状是一摸一样的,只是说,根据整个句子的&quot;句意矩阵&quot;对句子中的每一个词的&quot;表示向量&quot;做出了调整.而且,由于是自己和自己相乘,所以这个过程就是<strong>自</strong>注意力机制.</p>
<p>同时,这个过程和人类的语言习惯也是相统一的,同样的词语必然需要根据不同的句子赋予不同的意义,比如&quot;苹果手机&quot;和&quot;收集苹果&quot;.</p>
<p><img src="%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BE%8B%E5%AD%90.png" alt="例子" title="例子"></p>
<h3 id="Self-Attention-in-Transformer">Self-Attention in Transformer</h3>
<p>然后我们看看transformer是如何应用self-attention的.</p>
<p><img src="%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6.png" alt="Self-Attention" title="Self-Attention"></p>
<p>为了增强自注意力的效果,在正式的计算之前,先使用矩阵$W_Q$(查询矩阵),$W_K$(键矩阵),$W_V$(值矩阵),对input($X$)进行修正.</p>
<p>$$<br>
Q=X\cdot W_Q\<br>
K=X\cdot W_K    \<br>
V=X\cdot W_V<br>
$$</p>
<p>这样得到了三个不同的矩阵Q(查询),K(键值),V(值).这里的$Q,K,V$相比于$X$行数不变,列数有变化;等价于单词的数量不变但是衡量每一个单词的特征的数量发生了改变.</p>
<p>然后,这三个被传入上图所示的机制,计算实现Self-Attention:</p>
<p>$$<br>
Z=Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V<br>
$$</p>
<p>下面这个图或许可以更好的表达整个过程.</p>
<p><img src="self-attention.png" alt="self-attention" title="self-attention"></p>
<p>这里,为了防止内积过大,因此除以$d_k$,也即是$K$的列数.同样的,整个过程没有改变X的行数,只是改变了列数.这里的$Z$就是self-Attention的输出矩阵.</p>
<h3 id="Multi-Head-Attention">Multi-Head Attention</h3>
<p>在上一步，我们已经通过 Self-Attention 计算得到输出矩阵 $Z$，但是这还不够.其中的一个原因在于,这样得到的句子的信息不够,在准确率上有所不足.解决这个问题的本质就是要从句子中提取更多的信息,这里一个朴素的想法就是,‘多读几遍’.而Multi-Head Attention就是这样的想法.</p>
<p><img src="Multi-Head%20Attention.png" alt="Multi-Head Attention" title="Multi-Head Attention"></p>
<p>从上图可以看到 Multi-Head Attention 包含多个 Self-Attention 层，首先将输入$X$分别传递到 h 个不同的 Self-Attention 中，计算得到 h 个输出矩阵Z。这里是 h=8 时候的情况，也就是会得到 8 个输出矩阵Z。</p>
<p>然后把输出的$Z_i$拼接到一起,再使用一个矩阵做一个线性变化,使得multi-head attention前后的矩阵大小不变.类比的讲,我们可以很自然的想到,这个线性变换(Linear)就相当于把好几次阅读得到的信息融合在了一起.</p>
<p>下面的这张图有一点小问题,最左边的矩阵的$X$和$D_X$写反了,中间的小矩阵倒是写的是正确的;不过这个图看起来更直观,所以还是放在这里.</p>
<p><img src="Multi-Head%20Attention-%E7%A4%BA%E6%84%8F.png" alt="MHA表示" title="MHA表示"></p>
<h3 id="Multi-Layer-Self-Attention">Multi-Layer Self-Attention</h3>
<p>这个想法我觉得太自然不过了,知道考虑考虑我们的MLP就可以明显的看出网络数量上升的好处.不所以这里不是想讨论这样的机制,而是觉得这个图很有意思,我第一次没有看懂,感觉值得拿出来聊聊.</p>
<p><img src="Multi-Layer%20Self-Attention.png" alt="Multi-Layer Self-Attention" title="Multi-Layer Self-Attention"></p>
<p>上图中,每一个大矩形包裹的就是一个Self-Attention in Transformer,<strong>一个六边形表示一个词和其他词的注意力</strong>,仔细看看可以看到每一个六边形的红色点是不一样的.在一个Self-Attention in Transformer实现之后,使用某种非线性函数$f(\cdot)$再把输出传到下一个Self-Attention in Transformer中,如此循环几次即可.</p>
<h2 id="Encoder">Encoder</h2>
<p>在讨论完Self-Attention之后我们总算可以正式的进入Transformer了.</p>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>上图左边浅橙色的部分就是我们的encoder,或者说encoder block,因为我们要把这个结构反复使用$N$次.</p>
<p>之前我们已经着重讲过了Multi-Head Attention了,所以这里把目光放在Add &amp; Norm和Feed Forward上.</p>
<h3 id="Add">Add</h3>
<p>Add也就是残差连接,用公式表达就是$X + MultiHeadAttention(X)$,这样的操作在RNN中就已经见到了,好处是避免了反向传播中的梯度消失.</p>
<p>这里就可以看到保持$Z$和$X$的形状一样的好处了.</p>
<h3 id="Norm">Norm</h3>
<p>归一化就更没什么好说了,就是高斯/正太化了.$LayerNorm(X+MultiHeadAttention(X))$<br>
Layer Normalization 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。</p>
<h3 id="Feed-Forward">Feed Forward</h3>
<p>Feed Forward 层比较简单，是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数$ReLu(XW_1+b_1)W_2+b_2$</p>
<h3 id="我来组成头部">我来组成头部</h3>
<p>Multi-Head Attention, Feed Forward, Add &amp; Norm 就可以构造出一个 Encoder block，Encoder block 接收输入矩阵 $X$，并输出一个矩阵 $C$.通过多个 Encoder block 叠加组成 Encoder。</p>
<p>第一个 Encoder block 的输入为句子单词的表示向量矩阵，后续 Encoder block 的输入是前一个 Encoder block 的输出，最后一个 Encoder block 输出的矩阵就是编码信息矩阵 C，这一矩阵后续会用到 Decoder 中。</p>
<h2 id="Decoder">Decoder</h2>
<p><img src="transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="transformer整体架构" title="transformer整体架构"></p>
<p>上图右边浅橙色的部分就是我们的decoder,或者说decoder block,因为我们同样要把这个结构反复使用$N$次.</p>
<p>这里虽然右两个但是本质上是一样的,都是我们的Multi-Head Attention,只是输入的$X$和之前的不一样了.</p>
<p>概况的说就是:</p>
<ul>
<li>第一个 Multi-Head Attention 层采用了 Masked</li>
<li>第二个 Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q使用上一个 Decoder block 的输出或者输入$X$计算</li>
</ul>
<blockquote>
<p>这里不妨想一想为什么有&quot;Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算&quot;这个安排.</p>
</blockquote>
<h3 id="Mask-Multi-Head-Attention">Mask Multi-Head Attention</h3>
<p>Mask,遮挡,我感觉这是很符合直觉,但是我想不到的东西,就是听了别人的介绍感觉平平无奇,但是自己去想绝对想不到的东西.</p>
<p>它来自一种现实,就是我们做翻译的时候,只知道翻译之后的内容的前文而不知道后文.<s>想象你正在看一本英文书,英文的内容自然是完整的,但是中文的意思却是一个一个顺序出现的</s>.所以,在计算<strong>注意力</strong>的时候就要屏蔽掉这个词语和那些句子中在它后面的词语的联系.<s>感觉这里有点绕</s></p>
<p>不知道你还记不记得<strong>注意力</strong>的概念,其实就是一句话中,一个单词和其它所有的单词的联系的紧密程度,一般的度量就是灵感单词的<strong>表示向量</strong>的内积的大小,由于句子中的每一个词都需要得到自己的注意力,所以实际计算的时候是句子的<strong>词义矩阵</strong>和他本身的转置的点乘.</p>
<p>但是,前文也说过了,在transformer中,为了更好的表现,我们使用线性变换把$X$转化为了$Q,K,V$,而且还说过$Z=Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V$.不知道这里你能不能看出来哪个部分是<strong>注意力矩阵</strong><s>这是我现造的词</s>.</p>
<p>其实是$Q\cdot K^{T}$,我们只要再用一个mask矩阵,和他做点乘就好,也即是$Q\cdot K^T\cdot mask$.</p>
<p>那么,什么样的mask矩阵可以满足这样的要求?如下所示:</p>
<p>$$\begin{bmatrix}<br>
{1}&amp;{0}&amp;{\cdots}&amp;{0}\<br>
{1}&amp;{1}&amp;{\cdots}&amp;{0}\<br>
{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>
{1}&amp;{1}&amp;{\cdots}&amp;{0}\<br>
\end{bmatrix}$$</p>
<p>这样一来,我们的attention就会演变成这样:$Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}\cdot Mask}{\sqrt{d_k}})\cdot V$</p>
<p>我们得到一个 Mask Self-Attention 的输出矩阵 ，和 Encoder 类似，通过 Multi-Head Attention 拼接多个输出然后线性变换,得到第一个 Multi-Head Attention 的输出Z，Z与输入X维度一样.</p>
<blockquote>
<p>事实上,在我要写Multi-Head Attention-2的时候,我忽然意识到,这里可能会产生一点歧义;就是,Mask Multi-Head Attention的输入.</p>
<p>我想说的是,Mask Multi-Head Attention的输入和encoder没有显示的关系,<s>第二个decoder block之后自然会有隐式的联系</s>!Mask Multi-Head Attention的输入中的$Q,K,V$是一个矩阵$X$变换得到的!</p>
</blockquote>
<h3 id="Multi-Head-Attention-2">Multi-Head Attention-2</h3>
<p>好吧,Multi-Head Attention-2也很好理解.唯一值得注意的就是其中 Self-Attention 的 $K, V$矩阵不是使用 上一个 Decoder block 的输出计算的，而是使用 Encoder 的编码信息矩阵 $C$ 计算的.</p>
<p>不知道你还记不记得之前的问题.</p>
<blockquote>
<p>这里不妨想一想为什么有&quot;Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算&quot;这个安排.</p>
</blockquote>
<p>其实不难回答,想想看我们现在的$Q,K,V$分别是怎么得到的:</p>
<p>$$<br>
Q=X\cdot W_Q\<br>
K=C\cdot W_K    \<br>
V=C\cdot W_V<br>
$$</p>
<p>再想想看,什么是注意力:$Attention(Q,K,V)=softmax(\frac{Q\cdot K^{T}}{\sqrt{d_k}})\cdot V$我们相当于考察了输入的$X$,<s>比如是一个start标志</s>,和需要被翻译的句子中的内容的关系;然后根据这个关系,对被翻译的句子中的内容进行调节.</p>
<p>这样做的好处是在 Decoder 的时候，每一个输出的单词都可以利用到 Encoder 所有单词的信息.</p>
<h2 id="Softmax">Softmax</h2>
<p>结束了Decoder,因为它也是一个&quot;Multi-Head&quot;,所以先做一个线性变换,使大小和一开始一样.然后使用softmax完成打分.</p>
<p>再后面就和MLP的后续没有任何区别,和decoder输入的$X$比较,得到loss和正确率,选择合适的优化器求梯度等等.</p>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>Transformer 没有利用单词的顺序信息的，需要在输入中添加位置 Embedding.</p>
</li>
<li>
<p>Self-Attention 结构是Transformer 的重点，其中用到的 Q, K, V矩阵通过$X$线性变换得到.</p>
</li>
<li>
<p>Multi-Head Attention 中有多个 Self-Attention，目的是捕获单词之间更多的联系.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>transformer</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>免疫生物学-一周目</title>
    <url>/blog/2023/09/20/%E5%85%8D%E7%96%AB%E7%94%9F%E7%89%A9%E5%AD%A6-%E4%B8%80%E5%91%A8%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="免疫细胞的来源">免疫细胞的来源</h2>
<h3 id="骨髓和淋巴系统">骨髓和淋巴系统</h3>
<p>身体中的绝大多数免疫细胞来自于<strong>多能造血干细胞(pluripotent hematopoietic stem cells)</strong>,只有很少的一部分的分布在中枢神经系统的吞噬细胞有其他的来源的.这里我们只考虑前者.多能造血干细胞在骨髓中完成分化后,一部分细胞保留在骨髓中实现成熟,比如B细胞;一部分细胞迁移到其他免疫器官,比如<strong>胸腺</strong>中成熟,比如T细胞;但是有意思的是,T细胞(T-lymphocytes)的T并不是来自胸腺(Thymus).不论在哪里成熟,免疫细胞在成熟之后就会进入到**淋巴系统(lymphatic system)**中,淋巴系统会接收组织液中的淋巴细胞,在锁骨下实现和血液的交换.</p>
<h3 id="骨髓造血干细胞的演化">骨髓造血干细胞的演化</h3>
<p>所有的血细胞,包括运输氧气的红细胞(red blood cells),修复破损的血小板(platelets)和免疫系统的白细胞(white blood cells)都是通过骨髓造血干细胞(hematopoietic stem cells,HSCs)分化而来的.HSCs随后会分化为淋巴细胞系(lymphoid)和骨髓细胞系(myeloid)的直接祖细胞,下图对这个过程有着详细的描述.</p>
<p><img src="%E5%85%8D%E7%96%AB%E7%BB%86%E8%83%9E%E7%9A%84%E6%BC%94%E5%8C%96.png" alt="多能细胞(pliripotent cells)分化为共同淋巴祖细胞(common lymphoid progenitor)和共同骨髓祖细胞(common myeloid progenitor).前者会进一步分化为淋巴系(lymphoid lineage);这些包括B细胞(B Cells),T 细胞(T Cells),自然杀伤细胞(natural killer cells,NK),先天淋巴细胞(innate lymphoid cells,ILCs),未成熟的树突状细胞(dendritic cells).后者会分化为骨髓系(myeloid lineage);这些包括其余的白细胞,红细胞(red blood cells,erythrocytes),会进一步演化为血小板的巨核细胞(megakaryocytes).t 淋巴细胞和 B 淋巴细胞与其他白细胞的区别在于它们具有抗原受体，而它们之间的区别在于它们的分化部位（分别是胸腺和骨髓）遇到抗原后，B细胞分化为分泌抗体的浆细胞，而T细胞则分化为具有多种功能的效应T细胞。与 t 细胞和 B 细胞不同，ILC 和 nK 细胞缺乏抗原特异性。其余的白细胞是单核细胞(monocytes)、树突状细胞(dendritic cells)、中性粒细胞(neutrophils)、嗜酸性粒细胞(eosinophils)和嗜碱性粒细胞(basophils)。其中最后三种在血液中循环，被称为粒细胞(granulocytes)，因为细胞质颗粒的染色使这些细胞在血涂片中具有独特的外观，或者被称为多形核白细胞，因为它们的细胞核形状不规则。未成熟的树突状细胞(Immature dendritic cells)是进入组织的吞噬细胞(phagocytic cells)；它们在遇到潜在的病原体后成熟。大多数树突状细胞源自骨髓共同祖细胞，但有些也可能源自淋巴共同祖细胞。单核细胞进入组织，在那里分化成吞噬巨噬细胞或树突状细胞。肥大细胞(monocytes)也进入组织并在那里完成成熟。" title="免疫细胞的演化"></p>
<blockquote>
<p>多能细胞(pliripotent cells)分化为共同淋巴祖细胞(common lymphoid progenitor)和共同骨髓祖细胞(common myeloid progenitor).前者会进一步分化为淋巴系(lymphoid lineage);这些包括B细胞(B Cells),T 细胞(T Cells),自然杀伤细胞(natural killer cells,NK),先天淋巴细胞(innate lymphoid cells,ILCs),未成熟的树突状细胞(dendritic cells).后者会分化为骨髓系(myeloid lineage);这些包括其余的白细胞,红细胞(red blood cells,erythrocytes),会进一步演化为血小板的巨核细胞(megakaryocytes).t 淋巴细胞和 B 淋巴细胞与其他白细胞的区别在于它们具有抗原受体，而它们之间的区别在于它们的分化部位（分别是胸腺和骨髓）遇到抗原后，B细胞分化为分泌抗体的浆细胞，而T细胞则分化为具有多种功能的效应T细胞。与 t 细胞和 B 细胞不同，ILC 和 nK 细胞缺乏抗原特异性。其余的白细胞是单核细胞(monocytes)、树突状细胞(dendritic cells)、中性粒细胞(neutrophils)、嗜酸性粒细胞(eosinophils)和嗜碱性粒细胞(basophils)。其中最后三种在血液中循环，被称为粒细胞(granulocytes)，因为细胞质颗粒的染色使这些细胞在血涂片中具有独特的外观，或者被称为多形核白细胞，因为它们的细胞核形状不规则。未成熟的树突状细胞(Immature dendritic cells)是进入组织的吞噬细胞(phagocytic cells)；它们在遇到潜在的病原体后成熟。大多数树突状细胞源自骨髓共同祖细胞，但有些也可能源自淋巴共同祖细胞。单核细胞进入组织，在那里分化成吞噬巨噬细胞或树突状细胞。肥大细胞(monocytes)也进入组织并在那里完成成熟。</p>
</blockquote>
<h2 id="淋巴系统">淋巴系统</h2>
<h3 id="淋巴细胞在骨髓和胸腺中成熟然后分布在全身的淋巴组织">淋巴细胞在骨髓和胸腺中成熟然后分布在全身的淋巴组织</h3>
<p>淋巴细胞在血液(blood)和淋巴液(lymph)中循环，并且在淋巴组织或淋巴器官中也大量存在，所谓淋巴器官就是其他非淋巴细胞的包裹下的淋巴细胞的聚集体。淋巴器官可大致分为中央(central lymphoid organs)或初级淋巴器官(primary lymphoid organs)，其中产生淋巴细胞；以及外周(peripheral)或次级(secondary)淋巴器官，其中维持成熟的幼稚淋巴细胞并启动适应性免疫反应。中央淋巴器官是骨髓(bone marrow)和胸腺(thymus)。外周淋巴器官包括淋巴结(lymph nodes)、脾脏(spleen)、肠道粘膜淋巴组织(mucosal lymphoid tissues of the gut)、鼻腔和呼吸道(nasal and respiratory tract)、泌尿生殖道(urogenital tract)和其他粘膜。主要淋巴组织的位置如图所示。淋巴结通过淋巴管系统(system of lymphatic vessels)相互连接，淋巴管从组织中排出细胞外液，将其携带通过淋巴结，然后将其存回到血液中.</p>
<p>产生 B 淋巴细胞和 T 淋巴细胞的祖细胞起源于骨髓。 B 细胞在骨髓内完成发育。虽然 B 淋巴细胞中的“B”最初代表法氏囊（ bursa of Fabricius），这是幼鸡体内淋巴细胞成熟的淋巴器官，但它对于骨髓来说是一个有用的助记符。 T 淋巴细胞的未成熟前体迁移到胸腺，并在那里完成发育，并由此得名。一旦完成成熟，两种类型的淋巴细胞都会以成熟的幼稚淋巴细胞(mature naive lymphocytes)的形式进入血流，并在外周淋巴组织中持续循环。</p>
<p>mature naive lymphocytes,这是一个很难翻译的说法,表示B或者T细胞已经在骨髓或者胸腺中发育完全并且进入血液但是还没有遇到抗原的状态.</p>
<p><img src="%E4%BA%BA%E4%BD%93%E6%B7%8B%E5%B7%B4%E7%B3%BB%E7%BB%9F.png" alt="淋巴系统的示意图" title="淋巴系统"></p>
<blockquote>
<p>淋巴细胞源自骨髓中的干细胞，并在中央淋巴器官（黄色）中分化——骨髓中的 B 细胞和胸腺中的 T 细胞。它们从这些组织迁移并通过血流输送到外周淋巴器官（蓝色）。这些包括淋巴结(lymph nodes)、脾脏(spleen)和与粘膜(mucosa)相关的淋巴组织，例如与肠道相关的扁桃体(gut-associated tonsils)、派尔氏淋巴结(Peyer’s patches)和阑尾(appendix)。外周淋巴器官是淋巴细胞被抗原激活的部位，淋巴细胞在血液和这些器官之间循环，直到遇到其特异性抗原。淋巴管将细胞外液从周围组织排出，这样一来,淋巴细胞就可以通过淋巴结进入胸导管，然后流入左锁骨下静脉。这种液体被称为淋巴液(lymph)，将树突状细胞和巨噬细胞吸收的抗原携带到淋巴结，并将淋巴细胞从淋巴结再循环回血液中。淋巴组织还与其他粘膜相关，例如支气管内壁（未显示）。</p>
</blockquote>
<h3 id="淋巴细胞在淋巴结中对抗原做出反应">淋巴细胞在淋巴结中对抗原做出反应</h3>
<p>抗原(antigen)和淋巴细胞(lymphocytes)最终在周围淋巴器官——淋巴结、脾脏和粘膜淋巴组织中相遇。成熟幼稚淋巴细胞(Mature naive lymphocytes)不断地通过这些淋巴器官再循环，而病原体抗原主要通过树突细胞从感染部位携带到这些组织。外周淋巴器官专门捕获携带抗原的树突状细胞并促进适应性免疫反应的启动。外周淋巴组织由<em>非白细胞基质细胞框架中的淋巴细胞</em>聚集组成，这些非白细胞基质细胞提供淋巴器官的<strong>基本结构组织和生存信号</strong>，以帮助维持淋巴细胞的生命。除淋巴细胞外，外周淋巴器官还含有常驻<strong>巨噬细胞和树突状细胞</strong>.</p>
<p>具体的来说,当皮肤等组织发生感染时，游离抗原和承载抗原的树突状细胞从感染部位通过<strong>传入淋巴管(afferent lymphatic vessels)<strong>进入</strong>引流淋巴结(draining lymph nodes)</strong>——外周淋巴组织，在那里它们激活抗原特异性淋巴细胞。然后，活化的淋巴细胞经历一段增殖和分化期，之后大多数通过传出淋巴管作为效应细胞离开淋巴结。它们返回到血液中，然后血液将它们带到它们将发挥作用的组织。这整个过程从识别抗原开始大约需要4-6天，这意味着对以前没有遇到过的抗原的适应性免疫反应要到感染后大约一周才会生效。还没有识别过抗原的成熟幼稚淋巴细胞((Mature naive lymphocytes))也会通过传出淋巴管返回血液，从血液中它们继续通过淋巴组织再循环，直到识别抗原或死亡.</p>
<blockquote>
<p>这里说&quot;返回&quot;是因为那些生存在淋巴结的淋巴细胞,一开始是从血液进入淋巴系统的.</p>
</blockquote>
<p><img src="%E6%B7%8B%E5%B7%B4%E5%BE%AA%E7%8E%AF.png" alt="淋巴循环" title="淋巴循环"></p>
<blockquote>
<p>淋巴和淋巴细胞通过胸导管回到了血液,幼稚淋巴细胞从血液中进入淋巴结,通过淋巴管抗原从被感染部分进入淋巴结.</p>
</blockquote>
<h2 id="淋巴器官">淋巴器官</h2>
<h3 id="淋巴结">淋巴结</h3>
<p>淋巴结是高度组织化的淋巴器官，位于淋巴系统血管的汇集点，淋巴系统是一个广泛的系统，它收集组织中的细胞外液并将其送回血液。淋巴液不断从血液中过滤产生，也可以成为淋巴,淋巴在不断产生的压力作用下从外周组织流出，由淋巴管或淋巴管输送,这些压力往往来源于肌肉运动。淋巴管中的单向阀可防止淋巴液逆流，也就是说,淋巴在身体中的流动是单方向的.</p>
<p>如上所述，传入淋巴管从组织中排出液体，将病原体和带有抗原的细胞从感染组织带到淋巴结。游离抗原通过细胞外液扩散到淋巴结，而树突状细胞则在趋化因子的吸引下主动迁移到淋巴结。同样的趋化因子还能吸引血液中的淋巴细胞，这些淋巴细胞通过穿过<strong>高内皮静脉（high endothelial venules,HEV）</strong>,这是一种的特殊血管壁,进入淋巴结。在淋巴结中，B 淋巴细胞分布在滤泡(follicles)中，滤泡构成了淋巴结的外皮层(outer cortex)。T淋巴细胞弥漫分布在皮质旁区域(paracortical areas)，也称为皮质深层或 T 细胞区。从血液迁移到淋巴结的淋巴细胞首先进入皮质旁区域(paracortical areas)，受到相同趋化因子的吸引，呈递抗原的树突状细胞和巨噬细胞也会在此聚集。通过淋巴结扩散的游离抗原会被这些树突状细胞和巨噬细胞捕获。抗原、抗原递呈细胞和幼稚 T 细胞在 T 细胞区创造了一个理想的环境，使幼稚 T 细胞能够结合其特异性抗原，从而被激活。</p>
<p>B 细胞的活化通常不仅需要与 B 细胞受体(B-cell receptor)结合的抗原(antigen)，还需要活化的辅助 T 细胞(activated helper T cells),一种效应 T 细胞,的配合。B 细胞和 T 细胞在淋巴结内的位置受其活化状态的动态调节。活化后，T 细胞和 B 细胞都会移动到滤泡和 T 细胞区的边界，在那里 T 细胞可以首先为 B 细胞提供辅助功能。一些 B 细胞滤泡包括生发中心(germinal centers)，在那里，活化的 B 细胞正在进行激烈的增殖和分化，变成浆细胞(plasma cells)。</p>
<p><img src="%E6%B7%8B%E5%B7%B4%E7%BB%93.png" alt="淋巴结" title="淋巴结"></p>
<blockquote>
<p>如图所示，淋巴结的横断面示意图左侧显示，淋巴结由最外层的皮质(outermost cortex)和内部的髓质(inner medulla)组成。皮质由外皮质的B细胞和相邻的副皮质区域组成，副皮质主要由T细胞和树突状细胞构成。当免疫反应进行时，一些被称为次级淋巴滤泡的滤泡中心会包含高度增生的B细胞区域，称为生发中心(germinal centers)。这些反应非常激烈，但随着生发中心老化而逐渐消失。从体液空间排出的淋巴通过传入淋巴管(afferent lymphatics)将组织中的抗原带到淋巴结中，这些抗原负载于吞噬作用的树突状细胞和吞噬作用的巨噬细胞中。它们直接从窦口(sinuses)迁移到淋巴结的细胞部分。淋巴通过髓质中的传出淋巴管(efferent lymphatic)离开。髓质由一系列巨噬细胞和分泌抗体的浆细胞组成，称为髓索。幼稚淋巴细胞通过特殊的毛细血管（未显示）从血液进入淋巴结，并通过传出淋巴管与淋巴一起离开。右侧的光镜照片显示了淋巴结的横断面，其中包含有生发中心的突出滤泡。放大倍数为×7。</p>
</blockquote>
<h3 id="脾脏">脾脏</h3>
<p>人类的脾脏是一个拳头大小的器官，位于胃的后方。它与淋巴系统没有直接联系，而是收集血液中的抗原，参与对血液中病原体的免疫反应。淋巴细胞通过血管进出脾脏。脾脏还收集和处理衰老的红细胞。其组织结构示意图见图。脾脏的大部分由红髓组成，是处理红细胞的场所。淋巴细胞环绕着穿过脾脏的动脉血管，形成淋巴管,也就是白髓.</p>
<p>动脉周围的淋巴细胞鞘称为动脉周围淋巴细胞鞘（periarteriolar lymphoid sheath,PALS），主要含有 T 细胞。淋巴滤泡(Lymphoid follicles)沿动脉间隔分布，主要含有 B 细胞。滤泡周围有一个被称为边缘区(marginal zone)的区域；该区域的 T 细胞很少，但巨噬细胞(macrophages)丰富，而且有一群常住的、不循环的 B 细胞，被称为边缘区 B 细胞(marginal zone B cells)。这些 B 细胞可迅速产生与细菌胶囊多糖亲和力低的抗体(low affinity to bacterial capsular polysaccharides)。这些抗体能在适应性免疫反应完全激活之前提供一定程度的保护。血液中的微生物、可溶性抗原以及抗原抗体复合物会被边缘区的巨噬细胞和未成熟树突状细胞从血液中过滤出来。就像未成熟树突状细胞从外周组织迁移到淋巴结的 T 细胞区一样，脾脏边缘区的树突状细胞在吸收抗原并被激活后，也会迁移到 T 细胞区。</p>
<p><img src="%E8%84%BE%E8%84%8F.png" alt="脾脏" title="脾脏"></p>
<blockquote>
<p>左上方的示意图显示脾脏由红髓（粉色区域）和淋巴样白髓交替组成，红髓是红细胞讲解的场所。人体脾脏的一个小部分放大图（右上方）显示白髓（黄色和蓝色）在中央动脉周围的离散区域的排列方式。大部分白髓在横截面中显示，有两个部分为纵切面。此图示下方的两个示意图显示了一横截面（中心下方）和一纵切面（右下方）的白髓放大图。中央动脉的周围是动脉周围淋巴鞘（periarteriolar lymphoid sheath,PAlS），由T细胞组成。淋巴细胞和负载抗原的树突状细胞在此处聚集。滤泡(follicles)主要由B细胞组成；在二级滤泡中(secondary follicles)，用B细胞冠(B-cell corona)围绕着生发中心(germinal center)。滤泡被所谓的边缘区淋巴细胞包围。在每个白髓区域，携带淋巴细胞和抗原的血液从小梁动脉流入中央动脉。从中央动脉出来的较小血管最终扩散，最终终止于人体脾脏中被称为髓外区（perifollicular zone,PFZ）的特殊区域，该区域环绕着每个边缘区。细胞和抗原然后通过髓外区的血液充填的开放空间进入白髓。左下方的光镜照片显示了成熟B细胞的人脾白髓的横截面免疫染色。滤泡和PAlS都被髓外区环绕。滤泡动脉出现在PAlS中（底部箭头），穿过滤泡，穿过边缘区，并进入髓外区（上部箭头）。Co，滤泡B细胞冠；gC，生发中心；mZ，边缘区；rP，红髓；箭头，中央动脉。</p>
</blockquote>
<h3 id="粘膜中的淋巴器官">粘膜中的淋巴器官</h3>
<p>大多数病原体通过粘膜表面进入体内，同时这些粘膜还会接触到空气、食物和体内自然微生物群等大量其他潜在抗原。粘膜表面由一个被称为粘膜免疫系统(mucosal immune system)或粘膜相关淋巴组织（mucosa-associated lymphoid tissues,MALT）的广泛组织系统保护。整个粘膜免疫系统估计含有与全身其他部分一样多的淋巴细胞，它们形成一组特殊的细胞，遵循与其他外周淋巴器官中的细胞略有不同的再循环规则。</p>
<p>肠相关淋巴组织（gut-associated lymphoid tissues,GALT）包括扁桃体(tonsil)、腺样体(adenoid)、阑尾(appendix)和小肠中的特殊结构—派氏斑(Peyer’s patches)，它从胃肠道上皮表面收集抗原。Peyer氏斑是一种重要且高度有序的组织，抗原由称为微小褶皱细胞或者M细胞(microfold or M cells)的特殊上皮细胞(epithelial cells)收集。淋巴细胞形成滤泡，包括由大量B淋巴细胞和环绕的少量T淋巴细胞构成的大中央圆顶(large central dome)。Peyer氏斑内的树突状细胞向T淋巴细胞传递抗原。淋巴细胞从血液进入Peyer氏斑，并通过外流淋巴管离开。在Peyer氏斑中产生的效应淋巴细胞通过淋巴系统进入血液循环，并重新分散到粘膜组织中执行它们的效应作用。</p>
<p>呼吸道和其他粘膜中存在类似但更弥漫的淋巴细胞聚集体：鼻相关淋巴组织（nasal-associated lymphoid tissue,NALT）和支气管相关淋巴组织（bronchus-associated lymphoid tissue,BALT）存在于呼吸道中。类似Peyer氏斑块，这些粘膜淋巴组织也被M细胞覆盖，通过这些M细胞，吸入的微生物和陷入呼吸道黏液覆盖物中的抗原可以通过。</p>
<p>因为它们参与启动适应性免疫反应，所以外周淋巴组织不是静态结构，而是变化很大，这主要取决于是否存在感染.弥漫性粘膜淋巴组织(diffuse mucosal lymphoid tissues)可能会因感染而出现，然后消失，而有组织的组织结构(architecture of the organized tissues)在感染期间会以更明确的方式发生变化。例如，随着B淋巴细胞增殖形成生发中心，淋巴结的B细胞滤泡扩张，整个淋巴结增大，这种现象被称为腺体肿胀(swollen glands)。</p>
<p><img src="%E8%82%A0%E9%81%93%E4%B8%AD%E7%9A%84%E6%B4%BE%E6%B0%8F%E7%BB%93.png" alt="派氏结" title="Peyer's patches"></p>
<blockquote>
<p>左图所示，派尔氏淋巴集结包含许多具有生发中心(germinal centers)的 B 细胞滤泡(B-cell follicles)。卵泡之间的区域被 T 细胞占据，因此被称为 T 细胞依赖区域(t-cell dependent areas)。表面上皮和滤泡之间的层称为上皮下圆顶(subepithelial dome)，富含树突状细胞、T 细胞和 B 细胞。派尔氏淋巴集结没有传入淋巴管，抗原直接从肠道穿过由所谓的微褶皱 (M) 细胞组成的特殊上皮进入。尽管该组织看起来与其他淋巴器官非常不同，但基本的划分仍然保留。与淋巴结中一样，淋巴细胞从血液穿过高内皮微静脉壁（未显示）进入派尔氏淋巴结，并通过传出淋巴管离开。 a 图中的光学显微照片显示了小鼠肠壁派尔氏淋巴结的切片。可以看到派尔氏集结位于上皮组织下方。 Gc，生发中心； TDA，T 细胞依赖区域(t-cell dependent areas)。图b是图a中框出的滤泡相关上皮的扫描电子显微照片，显示了M细胞，其缺乏正常上皮细胞上存在的微绒毛(microvilli)和粘液层(mucus layer)。每个 M 细胞表现为上皮表面的凹陷区域。图 c 是图 b 中方框区域的更高放大倍数视图，显示了 M 单元的特征性褶皱表面。 M 细胞是许多病原体和其他颗粒的进入门户。图a，苏木精和伊红染色，放大倍数×100；图 b ，×5000；图 c，×23,000。</p>
</blockquote>
]]></content>
      <categories>
        <category>生物</category>
        <category>免疫生物学</category>
      </categories>
      <tags>
        <tag>免疫生物学</tag>
        <tag>淋巴</tag>
        <tag>免疫反应</tag>
        <tag>病原体</tag>
      </tags>
  </entry>
  <entry>
    <title>关于butterfly主题的相关说明</title>
    <url>/blog/2023/09/04/%E5%85%B3%E4%BA%8Ebutterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="文章的基础设置">文章的基础设置</h2>
<p>当我们使用<code>hexo new &quot;关于butterfly主题的相关说明&quot;</code>建立了新的<code>.md</code>文件和对应的文件夹之后,在<code>.md</code>的开头会为我们自动生成一些基础的设置,其形式如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 关于butterfly主题的相关说明</span><br><span class="line">date: y-m-d h:m:s</span><br><span class="line">tags:</span><br><span class="line"><span class="code">    -</span></span><br></pre></td></tr></table></figure>
<p>但是,依然有一些设置是需要自己添加的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:  # 文章的题目</span><br><span class="line">date:   # 文章的建立的日期</span><br><span class="line">updated:    # 文章的最近的更新的日期</span><br><span class="line">tags:   # 文章的标签</span><br><span class="line">categories: # 文章的分类</span><br><span class="line">keywords:   # 文章的关键字</span><br><span class="line">description:    # 文章的描述</span><br><span class="line">top<span class="emphasis">_img:    # 文章页面顶部的图片,设置这个不会影响缩略图,但是我喜欢叫二者统一</span></span><br><span class="line"><span class="emphasis">cover:  # 文章在主页的缩略图</span></span><br><span class="line"><span class="emphasis">copyright:  # 显示文章的版权,默认使用post_</span>copyright中的enable的设置</span><br><span class="line">copyright<span class="emphasis">_author:   # 本篇文章的作者,可能和博主不是一个人,不过我这里似乎没有这个问题</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:  # 文章作者的连接</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:  # 文章版权模块的文章连接</span><br><span class="line"><span class="section">copyright<span class="emphasis">_info: # 文章版权模块的版权声明</span></span></span><br><span class="line"><span class="emphasis"><span class="section">---</span></span></span><br></pre></td></tr></table></figure>
<p>事实上,依然有很多其他设置可以调整,但是我喜欢保持每个页面的统一,所以都使用了默认的模式.</p>
<h2 id="建立新文章和建立新页面">建立新文章和建立新页面</h2>
<p>文章和页面是两个不同的东西,文章就是你现在看到的东西,而页面是<em>分类,标签,友联</em>这样的东西.创建文章和页面采用的是不同的命令.</p>
<h3 id="建立文章">建立文章</h3>
<p>在<code>_post</code>文件夹下,打开<code>git</code>,输入下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章的名字&quot;</span>   <span class="comment"># 采用这样的方法,就实现了文章的建立</span></span><br></pre></td></tr></table></figure>
<h3 id="建立新页面">建立新页面</h3>
<p>在hexo博客的根目录,也就是<code>blog</code>目录,打开<code>git</code>,输入下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories/links/tags     <span class="comment"># 这样就建立了分类/友链/标签页面</span></span><br></pre></td></tr></table></figure>
<p>对不同的新页面会有一些不同的细节设置,具体可以参考<a href="https://butterfly.js.org/posts/dc584b87/#%E6%A8%99%E7%B1%A4%E9%A0%81">帮助文档</a></p>
<h2 id="标签外挂">标签外挂</h2>
<p>这隔功能我第一次见的时候就感觉很神奇,但是一直没有机会好好的研究,接着这次机会好好的琢磨一下<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%8C%89%E9%88%95%E6%8E%92%E5%BA%8F">帮助文档</a>给出了两种使用方法,这里一并介绍.</p>
<div class="note info simple"><p>标签外挂是Hexo独有的功能，并不是标准的Markdown格式。</p>
<p>以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p>
</div>
<div class="note warning simple"><p>标签外挂虽然能为主题带来一些额外的功能和UI方面的强化，但是，标签外挂也有明显的限制，使用时请留意。</p>
</div>
<h3 id="用法一">用法一</h3>
<p>这种方法采用了模板中给出的标记,使用方法如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>[可选]标识,不同的标识有着不同的颜色: <em>default / primary / success / info / warning / danger</em></td>
</tr>
<tr>
<td>no-icon</td>
<td>[可选]不显示icon</td>
</tr>
<tr>
<td>style</td>
<td>[可选]使用新的style覆盖配置中的默认style</td>
</tr>
</tbody>
</table>
<h3 id="用法二">用法二</h3>
<p>事实上,这个和上一个没有什么本质区别,只是用户可以根据自己的喜欢选择合适的<code>icon</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>【可选】顔色<em>default / blue / pink / red / purple / orange / green</em></td>
</tr>
<tr>
<td>no-icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>[可选]可以覆盖配置中的 style(simple/modern/flat/disabled)</td>
</tr>
<tr>
<td>fontawesome 图标</td>
<td>'fas fa-bullhorn’形如这样的格式进行使用,具体可以参考官方<a href="https://fontawesome.com/v4/icons/">介绍</a></td>
</tr>
</tbody>
</table>
<h2 id="tag-hide">tag-hide</h2>
<p>我感觉这是一个很帅的功能,但是我自己应该用不到,所以只是贴出<a href="%5Bhttps://butte%5D(https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A)">官方的介绍</a></p>
<h2 id="mermaid">mermaid</h2>
<p>使用<a href="http://mermaid.js.org/#/">mermaid标签</a>可以绘制Flowchart(流程图)/Sequence diagram(时序图)/Class Diagram(类别图)/State Diagram(状态图)/Gantt(甘特图)和Pie Chart(圆形图).</p>
<p>首先需要在主题配置文件中做一些修改:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure>
<p>然后是一些案例:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
<p>这个是一般的使用范式</p>
<h3 id="案例">案例</h3>
<p>下面是一个流程图(Flowchart)的案例以及对应的代码:</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
  </pre></div>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD;</span><br><span class="line"><span class="code">    A--&gt;B;</span></span><br><span class="line"><span class="code">    A--&gt;C;</span></span><br><span class="line"><span class="code">    B--&gt;D;</span></span><br><span class="line"><span class="code">    C--&gt;D;</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Tabs">Tabs</h2>
<p>同样是一个十分酷炫的功能,可以实现这样的效果:</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
  </pre></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD;</span><br><span class="line"><span class="code">    A--&gt;B;</span></span><br><span class="line"><span class="code">    A--&gt;C;</span></span><br><span class="line"><span class="code">    B--&gt;D;</span></span><br><span class="line"><span class="code">    C--&gt;D;</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>虽然<a href="https://butterfly.js.org/posts/4aa8abbe/#Tabs">文档</a>给出了4种不同的使用方法,但是对于我只有<em>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</em>这个选项是有用的:</p>
<div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fa fa-code"></i>代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 代码 @fa fa-code --&gt;</span><br><span class="line"><span class="strong">****</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="inlineImg">inlineImg</h2>
<p>文章中的图片在没有特别说明的情况下都是<code>块级元素</code>但是有时候我们会需要<code>内联元素</code>这个时候就需要使用这个标签外挂.</p>
<p><img src="cover.jpg" alt="块级元素" title="这是块级元素的封面"></p>
<p>这里是内联元素的封面<img class="inline-img" src="cover.jpg" style="height:150px"></p>
<p>这里是对应的代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">块级元素</span>](<span class="link">cover.jpg &quot;这是块级元素的封面&quot;</span>)</span><br><span class="line"></span><br><span class="line">这里是内联元素的封面&#123;% inlineImg cover.jpg 150px %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语">结语</h2>
<p>以上就是我觉得未来可能会用到的功能,如果以后发现上面的内容不够用,会把新使用的功能补充上来.</p>
]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>利用git实现本地文件和远程仓库的同步</title>
    <url>/blog/2023/08/28/%E5%88%A9%E7%94%A8git%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="我的场景—本地文件夹有内容">我的场景—本地文件夹有内容</h2>
<h3 id="步骤一-创建一个新的GitHub仓库">步骤一:创建一个新的GitHub仓库</h3>
<ol>
<li>GitHub网站上登陆账号</li>
<li>点击右上角加号图标,选择&quot;New repository&quot;<br>
<img src="2023-08-28-07-28-52.png" alt="建立新仓库"></li>
<li>输入仓库名称,描述,并设置为公有或者私有</li>
</ol>
<blockquote>
<p>有一点值得指出,这里建立的仓库最好先不要建立&quot;BEADME&quot;和许可证文件,具体原因后文再说</p>
</blockquote>
<h2 id="步骤二-初始化本地文件夹为Git仓库">步骤二:初始化本地文件夹为Git仓库</h2>
<p>在本地文件夹中右键打开<strong>Git Brash</strong></p>
<p>或者可以在任何地方打开<strong>Git Brash</strong>,然后使用<code>cd D:\xxx\xxx\xxx</code>进入本地文件</p>
<p>然后初始化Git仓库并且把它连接到远程的GitHub仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init    <span class="comment">#   这个命令运行之后会在根目录中看到一个&quot;.git&quot;文件夹</span></span><br></pre></td></tr></table></figure>
<p>然后添加文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .   <span class="comment">#   把本地的文件都先加载到缓冲区</span></span><br></pre></td></tr></table></figure>
<p>然后设置本次操作的说明:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;你的操作说明,比如:第一次上传本地文件&quot;</span></span><br></pre></td></tr></table></figure>
<p>选择分支,这里要和GitHub中的对应上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -M main  <span class="comment"># 也可以是是master</span></span><br></pre></td></tr></table></figure>
<p>如果不小心搞错了分支,可以使用一下命令换回:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m master main   <span class="comment"># 从分支master换到main</span></span><br></pre></td></tr></table></figure>
<p>然后连接远程仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/&lt;GitHub用户名&gt;/&lt;仓库名称&gt;.git</span><br></pre></td></tr></table></figure>
<p>这里,因为我们在本地有文件,并且我一开始犯了一个错误,就是建立了<strong>README</strong>和许可证文件,所以操作会比较麻烦.</p>
<p>首先,把远端仓库拉取到本地,并且允许合并不相关的历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main --allow-unrelated-histories  </span><br></pre></td></tr></table></figure>
<p>然后,把本地的变更推送到远程仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
<p>这样的操作会导致合并的历史不太整洁,不过我们这里还只是创建,所以影响不大.同时,最好关掉你的<strong>VPN</strong>,如果开启可能会出现&quot;<code>fatal: unable to access 'https://github.com/a-green-hand-jack/Benign-Overfitting.git/': Recv failure: C onnection was reset</code>&quot;这样的报错,这说明你在同步的时候遇到了一些网络问题.</p>
<p><img src="2023-08-28-08-04-38.png" alt="错误的网络"></p>
<p>很好,如果一切顺利,这个时候你就应该实现了本地和远程的同步!</p>
<h2 id="使用ssh协议推送和拉取代码">使用ssh协议推送和拉取代码</h2>
<p>正如前文所述的那样,<code>pull</code>和<code>push</code>的时候,为了网络的稳定,最好关闭<strong>VPN</strong>.但是有的时候,登录GitHub网页又需要使用<strong>VPN</strong>,如果反复的关闭,连接就很麻烦.这个时候可以考虑使用<strong>ssh协议</strong>,这可以提高推送和拉取时的稳定性.</p>
<h3 id="假设已经有了一个ssh密钥">假设已经有了一个ssh密钥</h3>
<p>在git中切换到ssh协议进行操作,首先验证一下是否能够连接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>然后,使用<code>git remote</code>修改远程仓库的URL:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github.com:&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure>
<p>最后,只要像之前一样的<code>pull</code>和<code>push</code>就好了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
<h3 id="检查之前建立的密钥">检查之前建立的密钥</h3>
<p>首先检查一下现有的密钥,在<code>git</code>里面:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>这样会列出<code>C:\Users\XXX\.ssh</code>文件中的所有的密钥</p>
<p>然后,我们可以检查一下现有的公钥的内容,如果你的<code>git</code>打开的位置不在<code>C:\Users\XXX\.ssh</code>文件夹下,请先转到对应的位置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:Users/XXX/.ssh</span><br></pre></td></tr></table></figure>
<p>然后,就可以打开公钥查看了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>请注意，SSH 密钥是敏感信息，私钥应当保密并妥善保存。不要在不受信任的地方公开或共享您的私钥。如果您怀疑私钥可能已经泄露，应当立即生成新的密钥对。</p>
<h3 id="生成新的密钥">生成新的密钥</h3>
<p>在git中输入以下命令来生成新的SSH密钥对:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>这将生成一个新的 RSA 密钥对，默认情况下保存在 ~/.ssh/id_rsa（私钥）和 ~/.ssh/id_rsa.pub(公钥)</p>
<p>然后输入以下内容来查看生成的公钥的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>复制生成的公钥内容，确保复制的内容是完整的公钥格式。</p>
<p>将公钥内容粘贴到您希望使用 SSH 密钥进行身份验证的地方，例如 GitHub 或其他远程服务器。</p>
<p>请注意，生成新的密钥对会替代之前的密钥，因此在更新密钥时，您需要更新相应的授权设置，例如 GitHub 上的 SSH 密钥设置.</p>
<h2 id="忽略程序运行中的大文件">忽略程序运行中的大文件</h2>
<p>有时候,我们编辑的虽然是<code>.py</code>或者<code>.ipynb</code>之类的文本文件,但是文件运行的过程中会产生一些很大的文件,这些部分有时候是不用上传的,我们有好几种方法来忽略它</p>
<h3 id="在-gitignore-文件中排除文件">在 <code>.gitignore</code> 文件中排除文件</h3>
<p>在您的项目根目录下创建一个名为 <code>.gitignore </code>的文件，然后在文件中添加一行 <code>cifar-10-python.tar.gz</code>这将告诉 Git 忽略这个文件，不将其纳入版本控制.</p>
<p>如果你需要忽略位于深层文件夹内的文件，可以在 .gitignore 文件中使用相对路径或通配符来指定这些文件。以下是一些示例：</p>
<ol>
<li>相对路径：</li>
</ol>
<p>假设你的大文件位于 <code>path/to/your/large_file.txt</code>，而你希望忽略它，可以在 <code>.gitignore</code> 文件中添加相对路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_file.txt</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通配符：</li>
</ol>
<p>如果你需要忽略某个文件夹内的所有内容，可以使用通配符 *。例如，如果你希望忽略 path/to/your/large_folder 内的所有文件，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/*</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>递归通配符：</li>
</ol>
<p>如果你需要递归地忽略某个文件夹及其子文件夹内的所有内容，可以使用双星号 **。例如，如果你希望忽略 path/to/your/large_folder 及其子文件夹内的所有内容，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/**</span><br></pre></td></tr></table></figure>
<p>这会将 <code>large_folder</code> 内的所有内容及其子文件夹都排除在版本控制之外.</p>
<p>使用这些方法，你可以在 <code>.gitignore</code> 文件中指定你想要忽略的深层文件夹内的文件。Git 将会自动忽略这些文件，确保它们不会被纳入版本控制.</p>
<h3 id="说明文件结构">说明文件结构</h3>
<p>在 <code>.gitignore</code> 文件中，使用的是相对于根目录的相对路径。所以，如果你的项目根目录是 <code>D:/XXX/YYY/ZZZ</code>，那么在 <code>.gitignore</code> 文件中指定 <code>path/to/your/large_folder</code>实际上是指定相对于根目录的路径。</p>
<p>具体而言，如果你的项目结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">D</span>:<span class="regexp">/XXX/</span><span class="variable constant_">YYY</span>/<span class="variable constant_">ZZZ</span>/</span><br><span class="line">  ├── path/</span><br><span class="line">  │    └── to/</span><br><span class="line">  │        └── your/</span><br><span class="line">  │            └── large_folder/</span><br><span class="line">  │                ├── large_file1.<span class="property">txt</span></span><br><span class="line">  │                ├── large_file2.<span class="property">txt</span></span><br><span class="line">  │                └── ...</span><br><span class="line">  ├── other_folder/</span><br><span class="line">  │    └── ...</span><br><span class="line">  ├── ...</span><br><span class="line">  └── .<span class="property">gitignore</span></span><br></pre></td></tr></table></figure>
<p>那么在 <code>.gitignore</code> 文件中的路径应该是相对于根目录的路径，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path/to/your/large_folder/</span><br></pre></td></tr></table></figure>
<p>这将会忽略 <code>large_folder</code> 及其内部的所有文件</p>
]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo和Github搭建个人博客</title>
    <url>/blog/2023/08/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-md/</url>
    <content><![CDATA[<h2 id="环境配置">环境配置</h2>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>输入代码时候,切换为英文输入法</li>
<li>文中的<strong>用户名</strong>和<strong>邮箱</strong>替换为自己的GitHub的<strong>账户名</strong>和绑定的<strong>邮箱</strong></li>
<li>使用<strong>Git Bash</strong>而不是Git GUI</li>
<li>以Windows10系统为例</li>
<li>假设已经拥有GitHub账户</li>
<li>博客根目录就是下载hexo的地址</li>
<li>在不熟悉操作的前提下请不要跳步</li>
</ol>
<h3 id="安装Git和Node-js">安装Git和Node.js</h3>
<p>首先在<a href="https://git-scm.com/downloads">Git</a>中下载和自己电脑系统相适应的版本;然后再<a href="https://nodejs.org/zh-cn">Nodes</a>中下载Nodes.js,这里建议使用<em>长期维护版</em>.<br>
下载之后的安装一直点击<code>next</code>就好.</p>
<p>安装完成之后,在cmd中输入命令查看版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="2023-08-25-01-50-52.png" alt="检查版本"></p>
<h2 id="配置GitHub">配置GitHub</h2>
<h3 id="连接GitHub">连接GitHub</h3>
<p>首先,在博客根目录中右键打开<code>git bash</code>,输入命令设置用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>
<p>然后,将Git绑定远程GitHub账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -keygen -t rsa -C <span class="string">&quot;GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行了上述指令之后,按下三个回车,然后复制<code>C:\Users\user-name\.ssh</code>中的<code>id_rsa.pub</code>中的内容.注意这里的<em>user-name</em>就是计算机用户的名字,每个人的不一样.</p>
<p>然后,进入GitHub个人账号,Setting-&gt;SSH and GPGkeys -&gt; New SSH key</p>
<p><img src="2023-08-25-02-04-44.png" alt="SSH and GPGkeys"><br>
<img src="2023-08-25-02-05-35.png" alt="New SSH key"></p>
<p>最后验证连接,在博客根目录下打开<em>Git Bash</em>输入<code>ssh -T git@github.com</code>,会得到<code>Hi user.name! You've successfully authenticated, but GitHub does not provide shell access. </code>这样的回复,就说明连接已经成功了.</p>
<h3 id="建立GitHub-Pages-仓库">建立GitHub Pages 仓库</h3>
<p>在主页面点击头像,进入<em>我的仓库</em>,然后在顶部点击<em>Create new</em>建立一个新的仓库,在Repository name <a href="http://xn--user-name-pl6ni7zuz8q.github.io">中输入user-name.github.io</a>,勾选<em>Initialize this repository with a README</em>,然后点击<em>Create repository</em></p>
<h2 id="Hexo配置">Hexo配置</h2>
<h3 id="Hexo博客程序的本地安装">Hexo博客程序的本地安装</h3>
<p>这个建立在Node已经成功安装的基础上,首先使用<code>npm</code>安装Hexo,这里建议使用<strong>魔法</strong>,不然下载会很慢.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="Hexo初始化和本地预览">Hexo初始化和本地预览</h3>
<p>首先在<em>cmd</em>中输入以下命令,实现初始化和组件安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init <span class="comment"># 初始化</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure>
<p>然后在<em>git bash</em>中输入命令,启动本地服务器并预览:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  # 生成页面</span><br><span class="line">hexo s  # 启动预览</span><br></pre></td></tr></table></figure>
<p>访问<code>http://localhost:4000</code>,出现了Hexo默认页面,说明本地博客安装成功</p>
<h3 id="博客的目录结构">博客的目录结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.landscape.yml   </span><br><span class="line">├── _config.yml   #全局配置文件，比如网站名称，副标题，秒速，作者，语言等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html.</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds   # 骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当hexo生成新博客的时候，会用这里面的模版进行初始化.</span><br><span class="line">├── source  # 这个文件夹下面存放的是网站的markdown源文件，里面有一个_post文件夹，所有的.md博客文件都会存放在这个文件夹下。现在有一个hello-world.md文件</span><br><span class="line">└── themes # 网站主题目录，hexo有非常丰富的主题支持，主题目录会存放在这个目录下面。更多的主题参见：https://hexo.io/themes/</span><br></pre></td></tr></table></figure>
<h3 id="部署Hexo到GitHub-Pages">部署Hexo到GitHub Pages</h3>
<p>首先,安装hexo-deployer-git:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后修改<code>_config.yml</code>文件末尾部分,结果如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>    <span class="comment"># 这里要求user-name.github.io中的主要分支是master</span></span><br></pre></td></tr></table></figure>
<p>然后,使用在<em>git bash</em>中使用<code>hexo d</code>把网站上传并部署到GitHub Pages.</p>
<p>然后访问<code>https://user-name.github.io</code>就可以看到自己的HExo博客了, 不过这里还没有自己写的内容</p>
<h2 id="年轻人的第一篇博客">年轻人的第一篇博客</h2>
<h3 id="建立书写博文">建立书写博文</h3>
<p>在<code>source</code>文件夹中,使用<code>hexo new &quot;first post&quot;</code>会建立一个<em>first <a href="http://post.md">post.md</a></em>文件,然后使用vscode之类的文本编辑器就可以以Markdown语言书写自己的博客文章了.</p>
<h3 id="另一种建立方法">另一种建立方法</h3>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tutorial:基于Hexo和Github搭建个人博客</span><br><span class="line">date: 2022-08-25 14:07:06</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> other</span><br><span class="line">keywords:</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="bullet">-</span> github</span><br><span class="line"><span class="section">- blog</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>
<h3 id="部署发布">部署发布</h3>
<p>依次使用<em>git bash</em>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g  # 生成页面</span><br><span class="line">hexo d  # 部署发布</span><br></pre></td></tr></table></figure>
<h2 id="其他问题">其他问题</h2>
<h3 id="更换主题">更换主题</h3>
<p>比如要下载一款经典的<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题,只要在<code>Blog</code>根目录下打开<em>git bash</em>,然后输入<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code>就实现了下载.<br>
然后在<code>_config.yml</code>文件中修改配置<code>theme: butterfly</code><br>
最后清除缓存<code>hexo clean</code>,再重新建立<code>hexo g</code></p>
<h3 id="插入图片">插入图片</h3>
<h4 id="下载插件">下载插件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>在<code>~\blog\node_modules\hexo-asset-image</code>中的<code>index.js</code>中的第58行把</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br></pre></td></tr></table></figure>
<p>修正为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, src);</span><br></pre></td></tr></table></figure>
<h4 id="修改配置文件">修改配置文件</h4>
<p>在_config.yml配置文件将<code>post_asset_folder:false</code>改成<code>true</code><br>
之后使用<code>hexo new &quot;blog name&quot;</code>的时候会同时生成同名文件夹用来存放资源(将所有图片放在这个文件夹内)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片的文字描述</span>](<span class="link">/如何使用Hexo和Github搭建个人博客-md/2023-08-25-02-47-12.png &quot;图片的名字&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="2023-08-25-02-47-12.png" alt="插入图片"></p>
<h4 id="利用VScode插件快速粘贴图片">利用VScode插件快速粘贴图片</h4>
<p>下载插件Paste Image ,在剪贴板有图片的情况下,按下<code>ctrl+alt+v</code>就会把图片插入到光标所在位置.<br>
但是这个时候图片存在的位置不对,在编译之前把它们放到正确的文件夹中.</p>
<h3 id="npm书写规范">npm书写规范</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo搭建个人博客</span><br><span class="line"><span class="section">#title:[空格]标题    #空格必须有</span></span><br><span class="line"><span class="section">#title: “标题” #如果标题中有双引号要用中文双引号</span></span><br><span class="line">date: 2021-11-15 22:16:30</span><br><span class="line"><span class="section">#添加多个tags的规范，注意 -[空格]Hexo #同样要有空格</span></span><br><span class="line">tags:   # 表签</span><br><span class="line"><span class="bullet">-</span> Hexo</span><br><span class="line"><span class="bullet">-</span> HTML</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="section">  - [技术分享, 博客制作]</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h3 id="插入视频连接">插入视频连接</h3>
<p>要在你的页面中播放Bilibili视频，而非直接跳转到Bilibili网站，你可以使用特定的播放器插件或工具来实现.在这种情况下，你可以尝试使用Bilibili的官方播放器插件“bilibili-player”，或者使用其他类似的第三方播放器插件来嵌入视频.</p>
<p>以下是一种使用bilibili-player插件的示例方法：</p>
<p>首先，确保你已经引入了bilibili-player插件的必要脚本和样式文件。然后，将以下代码插入到你想要显示视频的位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili-player&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili-player-video&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://player.bilibili.com/player.html?bvid=BV1FV4y1e7fB&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;autoplay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>确保将视频的BV号（bvid）替换为你想要嵌入的Bilibili视频的BV号.样，视频就会在你的页面中显示，并且只有在点击时才会跳转到Bilibili网站.</p>
<p>要调整嵌入视频的页面大小，你可以修改iframe元素的width和height属性值.通过调整这些值，你可以控制视频播放区域的宽度和高度:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://player.bilibili.com/player.html?bvid=BV1FV4y1e7fB&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;autoplay&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>    # <span class="attr">宽度是100</span>%</span></span><br><span class="line"><span class="tag"><span class="attr">height</span>=<span class="string">&quot;400px&quot;</span>&gt;</span> # 高度是400像素</span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>雕虫小技</category>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>扩散模型入门</title>
    <url>/blog/2024/05/22/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LLM与BioSequence</title>
    <url>/blog/2024/05/22/LLM%E4%B8%8EBioSequence/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着各种测序技术的发展，伴随着全球各地的研究人员的头发的牺牲，人类的知识库中多出了很多有关基因组、转录组、蛋白组的数据。但是如何合理的运用这些来之不易的数据却成了一个大问题，在过去的很长一段时间中，生物信息学的进步弥补这其中的缺陷。然而，这些方法往往涉及到一个问题“不够通用”，也就说，某一种方法只能在一类任务或数据集上使用。同时，注意力机制在自然语言生成（natural language genertaion）上的成功引发了人们的关注：能不能像处理自然语言一样处理序列信息？</p>
<p>在这样的想法的驱动下以及产生了很多优秀的工作，这里，笔者关注了<code>Geneformer</code>、<code>GenePT</code>、<code>scGPT</code>这3项工作。并在这里总结它们设计的用于评估模型表现力的下游任务以及这些任务对应的指标。</p>
<h1 id="GenePT"><a href="#GenePT" class="headerlink" title="GenePT"></a>GenePT</h1><!-- 整体上是在基因和细胞两个水平考察了模型嵌入是否反应了真实的生物学意义，并且力求在保留生物学意义的同时减小批次和组织特异性；在这样的思路的指导下根据合适的数据集设计了相关的下游任务。 -->
<p>使用 GPT-3.5 的单个基因的 NCBI 文本描述来生成基因嵌入；通过两种方式生成单细胞嵌入：（i）通过对基因嵌入进行平均，并根据每个基因的表达水平进行加权；（ii）通过使用按表达水平排序的基因名称为每个细胞创建一个句子嵌入；随后利用这些嵌入执行下游任务（如对基因属性和细胞类型的分类）。 GenePT 证明基于文献的大语言模型嵌入是获得生物基础模型的简单而有效的途径。</p>
<h2 id="两种水平的任务"><a href="#两种水平的任务" class="headerlink" title="两种水平的任务"></a>两种水平的任务</h2><h3 id="基因水平的任务"><a href="#基因水平的任务" class="headerlink" title="基因水平的任务"></a>基因水平的任务</h3><ol>
<li>基因功能类别预测：这是一个多分类预测跳转基于15个最常见的功能基因类别。这些类别的标签是作为<code>Geneformer</code>这个文章的一部分策划的。</li>
<li>基因属性预测任务：这包括4个二元分类任务，这些任务基于Theodoeis 等人提供的开源数据：<ol>
<li>区分先前确定的<em>剂量敏感转录因子</em>和 <em>剂量不敏感转录因子</em></li>
<li>区分二价基因和非甲基化基因</li>
<li>区分仅Lsy4甲基化和非甲基化基因</li>
<li>区分长程转录因子和短程转录因子</li>
</ol>
</li>
<li>基因-基因相关作用预测：理由Du等人开发并共享的基因-基因相互作用（GGI）基准。训练和测试数据集包括了200000对样本<code>（gene1,gene2,label）</code>，这里的<code>label</code>标记这一对基因是不是相互作用</li>
<li>蛋白质-蛋白质<code>（PPI）</code>相关作用：<ol>
<li>使用了3个数据集<ol>
<li><code>The human binary protein interactions (HuRI) dataset</code></li>
<li><code>comprehensive binary protein-protein interactions (Lit-BM)</code></li>
<li><code>tissue-specific protein-protein functional interaction networks</code></li>
</ol>
</li>
<li>这些数据集的基本形式是<code>(protein1, protein2, binary label)</code></li>
<li>这里的二元标签表明两个蛋白质之间是否存在相互作用</li>
<li>首先使用UniProt 转化工具把蛋白质的蛋白质组标志转化为基因名称；如果返回了多个基因名称，就随机选择一个</li>
</ol>
</li>
<li>基因程序的无监督探索<ol>
<li>检查基因之间的相互作用，使用来自<em>人类免疫组织数据集</em>的<code>GenePt</code>嵌入构建了一个基因-基因相互作用的相似性网络</li>
<li>基于高变基因之间的余弦相似度构建基因网络</li>
<li>应用Louvain 聚类来推到基因程序</li>
</ol>
</li>
<li>定性的比较<em>突出的基因程序的趋势</em>与它们<em>对应的细胞特异性表达水平</em> </li>
</ol>
<h3 id="细胞水平的任务"><a href="#细胞水平的任务" class="headerlink" title="细胞水平的任务"></a>细胞水平的任务</h3><ol>
<li><p>评估嵌入和底层细胞状态之间的关联：</p>
<ol>
<li>主动脉：包括11种细胞类型，最初由Li等人研究并发表的一个随机20%的数据子集</li>
<li>动脉：包含10种细胞类型</li>
<li>骨组织：<ol>
<li>骨骼：包含7种细胞类型</li>
<li>骨髓：包含3种已注释的癌症类型和11种细胞类型，总共13,468个细胞</li>
</ol>
</li>
<li>胰腺：包含4,218个细胞中注释的11种细胞类型</li>
<li><p>免疫细胞：从健康个体和多发性硬化症患者中收集，总共3,430个细胞中注释了18种细胞类型，来自12个供体。</p>
<ol>
<li><p>对于每个数据集及其关联的元数据注释，在预训练的 GenePT、Geneformer 或 scGPT 嵌入上应用 k 均值聚类，以获得与元数据注释中的类匹配的集群。</p>
</li>
<li><p>选择簇的数量 k 以匹配元数据注释中的类数量。</p>
<ol>
<li>计算<strong>调整兰德指数 (ARI) 和调整互信息 (AMI)</strong>，以评估派生簇标签与真实元数据标签之间的一致性。</li>
<li>推断标签和实际标签之间的较高对齐度（由<em>较高</em>的 ARI 或 AMI 值表示）表明嵌入捕获了更多的生物结构和信号。</li>
</ol>
</li>
<li><p>使用原始样本的真实注释计算了<strong>平均轮廓宽度（ASW）</strong>，以评估簇的凝聚力和分离度。</p>
</li>
</ol>
</li>
</ol>
</li>
<li>上下文感知和批量集成：<ol>
<li>评估 GenePT-s 嵌入是否受到常见批次效应的影响</li>
<li>Aorta 数据集</li>
<li>肌细胞数据集</li>
</ol>
</li>
</ol>
<h2 id="不同任务的结果"><a href="#不同任务的结果" class="headerlink" title="不同任务的结果"></a>不同任务的结果</h2><blockquote>
<p>说明结果的时候似乎不可避免的会提到指标，所以干脆在这里就一起说了吧。。。</p>
</blockquote>
<h3 id="基因功能类别判断"><a href="#基因功能类别判断" class="headerlink" title="基因功能类别判断"></a>基因功能类别判断</h3><ol>
<li><p>二维 UMAP 对GenePT 嵌入</p>
<ol>
<li><p>34000个基因</p>
</li>
<li><p>15个分类</p>
</li>
</ol>
</li>
</ol>
<p><img src="UMAP.png" alt="UMAP"></p>
<ol>
<li><p>$l<em>2$ 正则化逻辑回归 ($l</em>{2}$ regularized logistic refression)</p>
<ol>
<li><p>训练集和测试集分配是7：3</p>
</li>
<li><p>有15类不同的基因</p>
</li>
<li><p><code>class-specific accuracies</code></p>
</li>
</ol>
</li>
</ol>
<p><img src="class-specific-accuracies.png" alt="class-specific accuracies"></p>
<blockquote>
<p>也就是一个混淆矩阵</p>
</blockquote>
<h3 id="基因-基因相互作用预测"><a href="#基因-基因相互作用预测" class="headerlink" title="基因-基因相互作用预测"></a>基因-基因相互作用预测</h3><ol>
<li><p>比较了3种方法在<strong>GGI</strong>数据集上的<strong>ROC-AUC</strong></p>
<ol>
<li><p>GenePT</p>
</li>
<li><p>Gene2Vec</p>
</li>
<li><p>Geneformer</p>
</li>
<li><p>scGPT</p>
</li>
<li><p>Permuted</p>
</li>
</ol>
</li>
<li><p>使用了$l_2-regularized logistic classifier$ 也就是 LR分类器</p>
</li>
</ol>
<p><img src="gene-gene-inter.png" alt="gene-gene-inter"></p>
<h3 id="蛋白-蛋白相互作用预测"><a href="#蛋白-蛋白相互作用预测" class="headerlink" title="蛋白-蛋白相互作用预测"></a>蛋白-蛋白相互作用预测</h3><ol>
<li>指标是ROC-AUC</li>
<li>3种不同的模型<ol>
<li>GenePT</li>
<li>scGPT</li>
<li>geneformer</li>
</ol>
</li>
<li>3个数据集<ol>
<li>HuRI</li>
<li>L-it-BM</li>
<li>heart tissue</li>
</ol>
</li>
</ol>
<h3 id="细胞类型特异性激活"><a href="#细胞类型特异性激活" class="headerlink" title="细胞类型特异性激活"></a>细胞类型特异性激活</h3><ol>
<li>通过“零样本”方法研究了人类免疫组织数据集中 GenePT 衍生基因程序中的细胞类型特异性激活</li>
<li>根据GenePT embeddings之间的余弦相似度构建了相似度图</li>
<li>如果两个基因相似度大于0.9就用一个边把两个基因连接起来</li>
<li>使用20的分辨率对结果图进行Leiden 聚类</li>
</ol>
<p><img src="细胞类型特异性激活.png" alt="细胞类型特异性激活"></p>
<h3 id="GenePT-嵌入预测染色质动力学和剂量敏感性"><a href="#GenePT-嵌入预测染色质动力学和剂量敏感性" class="headerlink" title="GenePT 嵌入预测染色质动力学和剂量敏感性"></a>GenePT 嵌入预测染色质动力学和剂量敏感性</h3><ol>
<li>预测基因在网络动态中的作：<ol>
<li>剂量敏感与剂量不敏感的转录因子</li>
<li>二价基因与非甲基化基因</li>
<li>仅 Lys4 甲基化与非甲基化基因</li>
<li>长程转录因子与短程转录因子。</li>
</ol>
</li>
<li>使用 scikit-learn<ol>
<li>参数选择默认参数</li>
<li>五倍交叉验证的 ROC-AUC </li>
<li>l2 惩罚逻辑回归 (LR) 或随机森林 (RF) 分类器来评估 GenePT 和 Gene2vec 嵌入的性能</li>
</ol>
</li>
</ol>
<p><img src="嵌入预测染色质动力学和剂量敏感性.png" alt="嵌入预测染色质动力学和剂量敏感性"></p>
<h3 id="GenePT-学习了细胞生的生物学表征"><a href="#GenePT-学习了细胞生的生物学表征" class="headerlink" title="GenePT 学习了细胞生的生物学表征"></a>GenePT 学习了细胞生的生物学表征</h3><p>评估不同潜在细胞表示（通过llm嵌入得到）和生物注释（人类手工标记）之间的关联：</p>
<ol>
<li><p>该分析涉及代表来自循环系统（主动脉和动脉）、骨组织（骨骼、骨髓）、胰腺的细胞以及从健康个体和多发性硬化症患者收集的免疫细胞的数据集。</p>
</li>
<li><p>使用预训练的 Geneformer 和 scGPT 嵌入来完成此任务。</p>
</li>
<li><p>计算调整兰德指数 (ARI) 和调整互信息 (AMI)，</p>
<ol>
<li><p>以将 <strong>k 均值聚类得出的标签与原始样本的真实注释进行比较</strong>（值越高表示对齐效果越好）；</p>
</li>
<li><p>使用原始样本的真实注释计算<strong>平均轮廓宽度（ASW）</strong>，以评估簇的凝聚力和分离度。</p>
</li>
</ol>
</li>
</ol>
<h3 id="GenePT-嵌入消除了批次效应"><a href="#GenePT-嵌入消除了批次效应" class="headerlink" title="GenePT 嵌入消除了批次效应"></a>GenePT 嵌入消除了批次效应</h3><p>评估 GenePT 嵌入对于批次相关的技术工件（例如患者变异性）是否稳健。</p>
<ol>
<li><p>使用 Chaffin 等人的心肌细胞数据集中的 10% 随机样本，以及来自主动脉数据集的 20% 随机样本其中包含健康和扩张主动脉的细胞</p>
<ol>
<li><p>将 GenePT 与预训练的 Geneformer 和 scGPT 的性能进行了比较。</p>
</li>
<li><p>这两个样本都用于证明 Geneformer 的实用性。</p>
</li>
</ol>
</li>
<li><p>目的是区分不同的细胞类型</p>
</li>
<li><p>原始数据中细胞类型和患者的批次有强关联</p>
<ol>
<li><p>也就是说细胞簇和患者簇之间的ARI很高</p>
</li>
<li><p>这就说明批次效应强烈</p>
</li>
<li><p>但是不太希望嵌入器有这么高的批次效应</p>
</li>
</ol>
</li>
<li><p>幸运的是，GenePT等的ARI都不是很高，说明批次效应不明显</p>
</li>
</ol>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>可以看出，在基因任务上的一般思路是先用合适的LLM得到每一种基因的嵌入，也就是实现了从gene text/sequence到gene embedding 的转化。然后利用得到的gene embedding 执行下游任务如：聚类或者分类。这样一来，因为就可以使用聚类或者分类的结果和指标来表征LLM的嵌入效果的好坏。而常见的关于聚类和分类算法的指标有：</p>
<ol>
<li>聚类指标：<ol>
<li>调整兰德指数（Adjusted Rand Index, ARI）：评估聚类结果与真实标签的匹配度，值越高表示对齐效果越好。</li>
<li>调整互信息（Adjusted Mutual Information, AMI）：测量聚类结果与真实标签之间的互信息，值越高表示聚类结果越接近真实标签。</li>
<li>轮廓系数（Silhouette Score）：用于衡量聚类的一致性，值越高表示聚类效果越好。</li>
<li>平均轮廓宽度（Average Silhouette Width, ASW）：使用原始样本的真实注释计算，以评估簇的凝聚力和分离度。</li>
<li>这些指标可以用于将 k 均值聚类得出的标签与原始样本的真实注释进行比较，从而评估聚类的效果。</li>
</ol>
</li>
<li>分类指标：<ol>
<li>准确率（Accuracy）：分类正确的样本数占总样本数的比例。</li>
<li>精确率（Precision）：预测为正类的样本中实际为正类的比例。</li>
<li>召回率（Recall）：实际为正类的样本中被正确预测为正类的比例。</li>
<li>F1得分（F1 Score）：精确率和召回率的调和平均数，用于平衡这两者的权重。</li>
<li>ROC曲线下面积（AUC-ROC）：用于衡量分类模型的整体性能，值越接近1表示模型性能越好。</li>
<li>类别特定的准确率（Class-Specific Accuracies）：每个类别的准确率，可以通过混淆矩阵（Confusion Matrix）计算得到。</li>
</ol>
</li>
</ol>
<blockquote>
<p>混淆矩阵（Confusion Matrix）：一个矩阵表示实际类别与预测类别的对比情况，帮助识别模型在哪些类别上表现较好或较差。</p>
</blockquote>
<h1 id="scGPT"><a href="#scGPT" class="headerlink" title="scGPT"></a>scGPT</h1><p>语言和细胞生物学（其中文本由单词组成；类似地，细胞由基因定义）进行比较，探讨了基础模型在推进细胞生物学和基因研究方面的适用性。利用新兴的单细胞测序数据，构建了单细胞生物学的基础模型 scGPT，该模型基于跨超过 3300 万个细胞的存储库的生成预训练 Transformer。scGPT 有效地提炼了有关基因和细胞的关键生物学见解。通过进一步适应迁移学习，可以优化 scGPT，以在不同的下游应用程序中实现卓越的性能。这包括细胞类型注释、多批次集成、多组学集成、扰动响应预测和基因网络推理等任务。</p>
<h2 id="预训练后的基因嵌入"><a href="#预训练后的基因嵌入" class="headerlink" title="预训练后的基因嵌入"></a>预训练后的基因嵌入</h2><p>预训练后，使用统一流形近似和投影（UMAP）可视化3300 万个细胞中 10% 的人类细胞上的 scGPT 细胞嵌入。局部区域和簇的细胞类型通过不同的颜色准确表示。考虑到数据集中包含 400 多项研究，这证明了预训练提取生物变异的卓越能力。</p>
<h2 id="scGPT提高了细胞类型注释的精度"><a href="#scGPT提高了细胞类型注释的精度" class="headerlink" title="scGPT提高了细胞类型注释的精度"></a>scGPT提高了细胞类型注释的精度</h2><ol>
<li>微调预训练的 scGPT 以进行细胞类型注释<ol>
<li>神经网络分类器（network classifier）将 scGPT 变压器输出细胞嵌入作为输入并输出细胞类型的分类预测。</li>
<li>整个模型在带有专家注释的参考数据集上使用交叉熵进行训练——微调</li>
<li>然后用于预测保留的查询数据分区上的细胞类型——验证</li>
</ol>
</li>
<li>对不同的数据集进行了广泛的实验，以评估 scGPT 在细胞类型注释方面的性能。<ol>
<li>首先，用 scGPT 来预测人类胰腺数据集中的细胞类型，并考虑2个衡量指标<ol>
<li>预测</li>
<li>混淆矩阵</li>
<li>嵌入热图</li>
</ol>
</li>
<li>接下来，在多发性硬化症 (MS) 疾病数据集上测试了该模型。<ol>
<li>该模型在健康人体免疫细胞的参考分区上进行了微调，并根据对 MS 状况细胞的预测进行了评估。</li>
<li>同样考虑了混淆矩阵和热图作为衡量指标</li>
</ol>
</li>
<li>最后，在三个数据集中对微调后的 scGPT 与另外两种最近基于 Transformer 的方法 TOSICA31 和 scBERT32 进行了基准测试。 <ol>
<li>分类指标包括准确度、精确度、召回率和 F1</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="scGPT-预测不可见的遗传扰动反应"><a href="#scGPT-预测不可见的遗传扰动反应" class="headerlink" title="scGPT 预测不可见的遗传扰动反应"></a>scGPT 预测不可见的遗传扰动反应</h2><p>测序和基因编辑技术的最新进展极大地促进了大规模扰动实验，使得能够表征细胞对各种遗传扰动的反应。这种方法对于揭示新的基因相互作用和推进再生医学具有巨大的希望。然而，潜在基因扰动的巨大组合空间很快就超过了实验可行性的实际极限。为了克服这一限制，scGPT 可用于利用从已知实验中的细胞反应中获得的知识，并推断它们以预测未知的反应。在基因维度上利用自注意力机制可以对受干扰的基因与其他基因的响应之间复杂的相互作用进行编码。通过利用这种能力，scGPT 可以有效地从现有的实验数据中学习，并准确预测看不见的扰动的基因表达反应。</p>
<h3 id="预测不可见基因扰动"><a href="#预测不可见基因扰动" class="headerlink" title="预测不可见基因扰动"></a>预测不可见基因扰动</h3><ul>
<li><p><strong>扰动预测任务评估</strong></p>
<ul>
<li>使用白血病细胞系的三个 Perturb-seq 数据集评估了scGPT：<ol>
<li><strong>Adamson 数据集</strong><ul>
<li>包含 87 个单基因扰动</li>
</ul>
</li>
<li><strong>精选的 Replogle 数据集</strong><ul>
<li>包含 1,823 个单基因扰动</li>
</ul>
</li>
<li><strong>Norman 数据集</strong><ul>
<li>包含 131 个单基因扰动</li>
<li>包含 105 个单基因扰动和两基因扰动</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>评估方法</strong></p>
<ul>
<li>为了评估 scGPT 的扰动预测能力，对扰动子集的模型进行了微调，以在给定输入控制细胞状态和干预基因的情况下预测扰动的表达谱。</li>
<li>接下来，模型对涉及看不见的基因的扰动进行了测试。</li>
</ul>
</li>
<li><p><strong>评估指标</strong></p>
<ul>
<li><strong>Pearsondelta 指标</strong><ul>
<li>衡量预测和观察到的扰动后表达变化之间的相关性。</li>
</ul>
</li>
<li><strong>前 20 个变化最显著基因的指标</strong><ul>
<li>在差异表达基因上表示为 $Pearson_{\delta}$。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结果</strong></p>
<ul>
<li>使用原始研究的注释，发现相同功能组的扰动条件聚集在邻近区域</li>
<li>使用 Leiden 对预测的表达进行聚类，观察到这些聚类与扰动组合中的“显性基因”表现出高度关联。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<ul>
<li><strong>KLF1 基因相关的圆圈簇</strong><ul>
<li>表明该簇中的数据点经历了涉及 KLF1 和另一个基因（即 KLF1 + X）的组合扰动。</li>
</ul>
</li>
<li><strong>KLF1 和 CNN1 簇</strong><ul>
<li>验证了相应的预测表达在这些区域中专门高，这与 CRISPRa（CRISPR介导的转录激活）Perturb-seq 实验的预期结果一致。</li>
</ul>
</li>
<li><strong>显性基因簇</strong><ul>
<li>证明了 scGPT 揭示扰动组合之间关联的能力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="计算机逆扰动预测"><a href="#计算机逆扰动预测" class="headerlink" title="计算机逆扰动预测"></a>计算机逆扰动预测</h3><ul>
<li><p><strong>scGPT 的反向扰动预测能力</strong></p>
<ul>
<li><p>scGPT 能够预测给定结果细胞状态的遗传扰动来源，其称为计算机反向扰动预测。</p>
<ul>
<li>进行这种反向预测的理想预测模型可用于推断谱系发育的重要驱动基因或促进潜在治疗基因靶标的发现。</li>
<li>这种能力的一个假设应用示例可能是预测影响细胞从疾病状态中恢复的 CRISPR 靶基因。</li>
</ul>
</li>
<li><p>为了展示反向扰动预测的有效性，使用了 Norman 数据集的一个子集，重点关注涉及 20 个基因的扰动。</p>
<ul>
<li>该组合空间总共由 210 个单基因或两基因扰动组合组成。</li>
<li>使用 39 个（18%）已知扰动（图中的训练组）对 scGPT 进行微调。</li>
<li>然后，对未见过的扰动细胞状态的查询测试了模型，scGPT 成功预测了扰动源（在排名最高的预测内），从而生成了观察到的结果。</li>
</ul>
</li>
<li><p>具体示例：</p>
<ul>
<li>scGPT 将 CNN1 + MAPK1 基因的正确扰动列为一个测试示例的最佳预测。</li>
<li>将 FOSB + UBASH3B 基因的正确扰动列为另一个测试示例的第二预测。</li>
</ul>
</li>
<li><p>整体表现：</p>
<ul>
<li>scGPT 在前 1 个预测中平均识别出 91.4% 的相关扰动。</li>
<li>在前 8 个预测中识别出 65.7% 的正确扰动远远优于 GEARS 和差异基因基线。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="scGPT-支持多批次和多组学集成"><a href="#scGPT-支持多批次和多组学集成" class="headerlink" title="scGPT 支持多批次和多组学集成"></a>scGPT 支持多批次和多组学集成</h2><h3 id="多批次-scRNA-seq-集成"><a href="#多批次-scRNA-seq-集成" class="headerlink" title="多批次 scRNA-seq 集成"></a>多批次 scRNA-seq 集成</h3><ul>
<li><p><strong>整合多个 scRNA-seq 数据集的挑战</strong></p>
<ul>
<li>整合来自不同批次的多个 scRNA-seq 数据集在同时保留整合数据的生物方差和消除技术批次效应方面提出了独特的挑战。</li>
<li>为了整合测序样本，通过学习恢复隐藏基因表达的统一细胞呈现方式，以自我监督的方式微调 scGPT。</li>
</ul>
</li>
<li><p><strong>与其他集成方法的比较</strong></p>
<ul>
<li>在的基准测试实验中，将 scGPT 与三种流行的集成方法进行了比较：scVI38、Seurat39 和 Harmony40。</li>
<li>评估在三个集成数据集上进行，即 COVID-19（18 批）12、外周血单核细胞（PBMC）10k（两批）41 和鼻周皮质（两批）42 数据集。</li>
</ul>
</li>
<li><p><strong>PBMC 10k 数据集的性能</strong></p>
<ul>
<li>在 PBMC 10k 数据集中，scGPT 成功分离了所有细胞类型。</li>
<li>scGPT 的整合性能得到了其高生物保护评分的进一步支持，AvgBIO 评分为 0.821，比对比方法高 5-10%。</li>
</ul>
</li>
<li><p><strong>AvgBIO 分数</strong></p>
<ul>
<li>AvgBIO 分数汇总了三种细胞类型聚类指标，即标准化互信息 (NMIcell)、调整兰德指数 (ARIcell) 和平均轮廓宽度 (ASWcell)</li>
<li>scGPT 还表现出了相当大的性能，用于集成即使没有微调的 PBMC 10k 数据集，突出了预训练的普遍性。</li>
</ul>
</li>
<li><p><strong>鼻周皮层数据集的性能</strong></p>
<ul>
<li>在鼻周皮层数据集的背景下，scGPT 相对于所有其他方法仍然具有竞争力。</li>
<li>这一发现凸显了从全人类数据集中学到的特征应用于特定器官或组织（例如大脑）时的可转移性和鲁棒性。</li>
</ul>
</li>
<li><p><strong>其他指标表现</strong></p>
<ul>
<li>scGPT 在所有集成指标上始终取得有竞争力的分数，并表现出对生物信号的强大保护。</li>
<li>还制定了加速集成任务微调过程的策略，包括冻结特定模型层并排除不表达的基因，同时保持与原始方法相当的结果。</li>
</ul>
</li>
</ul>
<h3 id="单细胞多组学整合"><a href="#单细胞多组学整合" class="headerlink" title="单细胞多组学整合"></a>单细胞多组学整合</h3><ul>
<li><p><strong>scMultiomic 数据集整合</strong></p>
<ul>
<li>单细胞多组学 (scMultiomic) 数据结合了遗传调控的多种观点，例如表观遗传、转录组和翻译活动，在保留生物信号的同时聚合细胞表征提出了独特的挑战。</li>
<li>scGPT 通过有效地提取不同组学数据集中的集成细胞嵌入来解决这一挑战。</li>
</ul>
</li>
<li><p><strong>与其他方法的比较</strong></p>
<ul>
<li>在 10x 多组 PBMC 数据集43 中，将 scGPT 与两种最先进的方法 scGLUE13 和 Seurat (v.4)44 进行比较。<ul>
<li>scGPT 是唯一能够成功生成 CD8+ 初始细胞的独特簇的方法。</li>
</ul>
</li>
<li>在骨髓单核细胞 (BMMC)45 的配对基因表达和蛋白质丰度数据集上测试了 scGPT。<ul>
<li>scGPT 呈现出比 Seurat (v.4) 更明确的簇结构，AvgBIO 分数提高了 9%。</li>
<li>scGPT 能够将 CD4+ 初始 T 细胞和 CD4+ 激活 T 细胞分离为两个不同的簇，进一步证实了该模型捕获免疫细胞亚群之间细微差异的能力。</li>
</ul>
</li>
<li>在马赛克数据集成设置中，使用 ATAC 和选择抗原分析 (ASAP) 人类 PBMC 数据集46 作为示例。<ul>
<li>scGPT 表现出卓越的批量校正性能，特别是在 B、骨髓和自然杀伤 (NK) 细胞组中。</li>
</ul>
</li>
<li>scGPT 表现出卓越的细胞类型聚类性能，并在各种基准生物保护指标中表现出稳健性。</li>
</ul>
</li>
</ul>
<h2 id="scGPT-揭示特定细胞状态的基因网络"><a href="#scGPT-揭示特定细胞状态的基因网络" class="headerlink" title="scGPT 揭示特定细胞状态的基因网络"></a>scGPT 揭示特定细胞状态的基因网络</h2><p>GRN 背后的转录因子、辅因子、增强子和靶基因之间的相互作用介导重要的生物过程。现有的 GRN 推断方法通常依赖于静态基因表达的相关性或伪时间估计作为因果图的代理。 scGPT 通过基因表达的生成模型进行优化，在其基因嵌入以及注意力图中隐式编码了这种关系。因此，通过探测预训练或微调模型的 scGPT 嵌入和注意力图来提出 GRN 推理工作流程。<br>基因嵌入构建了一个相似性网络，该网络需要在数据集级别上进行基因间相互作用。注意力图进一步捕捉不同细胞状态下独特的基因网络激活模式。</p>
<ul>
<li><p><strong>基因标记嵌入的分组和区分</strong></p>
<ul>
<li>scGPT 展示了其通过学习基因标记嵌入对功能相关基因进行分组并区分功能不同基因的能力。</li>
<li>在图 5a 中，使用预训练的 scGPT 模型中的基因嵌入来可视化人类白细胞抗原 (HLA) 蛋白的相似性网络，从而进行了健全性检查。<ul>
<li>在这种零样本设置中，scGPT 模型成功突出显示了与明确表征的 HLA 类别相对应的两个簇：HLA I 类和 HLA II 类基因。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HLA 类别的功能</strong></p>
<ul>
<li>这些类别编码在免疫环境中发挥不同作用的抗原呈递蛋白。<ul>
<li>HLA I 类蛋白（由 HLA-A、HLA-C 和 HLA-E 等基因编码）可被 CD8+ T 细胞识别并介导细胞毒性作用。</li>
<li>HLA II 类蛋白（由 HLA-DRB1、 HLA-DRA 和 HLA-DPA1）被 CD4+ T 细胞识别并触发更广泛的辅助功能。</li>
</ul>
</li>
<li>在“免疫人类”数据集上微调了 scGPT 模型，并探索了该数据集中存在的免疫细胞类型特有的 CD 基因网络。</li>
</ul>
</li>
<li><p><strong>GRN 分析</strong></p>
<ul>
<li>为了进行 GRN 分析，使用了与集成任务相同的微调策略。</li>
<li>预训练的 scGPT 模型成功识别了编码用于 T 细胞激活的 T3 复合物的基因组（CD3E、CD3D 和 CD3G）、用于 B 细胞信号传导的 CD79A 和 CD79B 以及作为 HLA I 类分子共受体的 CD8A 和 CD8B 49。<ul>
<li>此外，微调的 scGPT 模型强调了 CD36 和 CD14 之间的联系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>GRN 指的是基因调控网络（Gene Regulatory Network），它是一种描述基因之间相互作用的网络结构。在生物学中，基因调控网络描述了基因与转录因子、miRNA 和其他基因调控元件之间的相互作用关系，以及这些相互作用如何影响基因的表达。基因调控网络对于理解基因调控的复杂性和细胞功能的调控机制非常重要，因为它们可以揭示基因调控网络中的关键因素和通路，并帮助研究人员理解生物体内的信号传导和细胞命运决定过程。</p>
</blockquote>
<h2 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h2><p><code>scGPT</code>和<code>GenePT</code>在下游任务和指标上有一定的重合。相比于<code>GenePT</code>，<code>scGPT</code>的任务要更复杂一些，好多也是第一次见，下面就分析一下。<br>基因扰动分析和计算机逆扰动预测是在基因组学和生物信息学领域中常见的任务，它们通常用于理解基因在细胞状态和生物学过程中的功能和影响。下面是它们的一般流程和一些评价指标：</p>
<h3 id="基因扰动分析："><a href="#基因扰动分析：" class="headerlink" title="基因扰动分析："></a>基因扰动分析：</h3><ol>
<li><strong>扰动数据收集：</strong> 收集包含基因扰动实验数据的数据集，例如基因编辑技术（如CRISPR）引发的基因敲除、过表达或突变。</li>
<li><strong>数据预处理：</strong> 对扰动实验数据进行预处理，包括数据清洗、去除噪声和异常值等。</li>
<li><strong>特征提取：</strong> 从基因扰动数据中提取特征，这可以包括基因表达水平的变化、蛋白质互作网络的改变等。</li>
<li><strong>分析和解释：</strong> 使用统计学和机器学习技术分析和解释基因扰动对生物过程的影响，可能会识别关键的调节基因、通路或生物学过程。</li>
<li><strong>评价指标：</strong> 常用的评价指标包括：<ul>
<li><strong>差异表达基因（DEGs）数量：</strong> 受扰动后基因表达水平显著变化的基因数量。</li>
<li><strong>富集分析：</strong> 基因扰动是否导致某些功能通路的显著富集。</li>
<li><strong>网络拓扑分析：</strong> 基因扰动是否影响了基因调控网络的结构和稳定性。</li>
<li><strong>生物学效应评估：</strong> 对于特定生物过程或疾病，基因扰动是否导致预期的生物学效应。</li>
</ul>
</li>
</ol>
<h3 id="计算机逆扰动预测："><a href="#计算机逆扰动预测：" class="headerlink" title="计算机逆扰动预测："></a>计算机逆扰动预测：</h3><ol>
<li><strong>建模：</strong> 使用机器学习或深度学习方法构建模型，该模型可以从基因表达数据中预测出导致这些表达模式的基因扰动。</li>
<li><strong>数据准备：</strong> 准备包含基因表达数据和相应基因扰动信息的训练集和测试集。</li>
<li><strong>特征工程：</strong> 对基因表达数据进行特征工程，可能包括降维、标准化或提取特征。</li>
<li><strong>模型训练：</strong> 使用训练集训练逆扰动预测模型，调整模型参数以提高预测性能。</li>
<li><strong>模型评估：</strong> 使用测试集评估模型的性能，通常使用常见的回归或分类指标进行评估。</li>
<li><strong>评价指标：</strong> 常见的评价指标包括：<ul>
<li><strong>均方误差（MSE）：</strong> 预测值与真实值之间的平均平方差。</li>
<li><strong>相关系数（Correlation Coefficient）：</strong> 预测值和真实值之间的线性相关性。</li>
<li><strong>准确率、召回率、F1 分数：</strong> 对于分类任务，评估模型对基因扰动的分类准确性。</li>
</ul>
</li>
</ol>
<p>综合来看，基因扰动分析和计算机逆扰动预测是通过对基因表达数据进行分析和建模来理解基因功能和影响的重要工具，评价指标可以帮助评估模型的性能和预测能力。</p>
<h1 id="geneformer"><a href="#geneformer" class="headerlink" title="geneformer"></a>geneformer</h1>]]></content>
      <categories>
        <category>大模型</category>
        <category>生命科学</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>NLP</tag>
        <tag>Bio</tag>
        <tag>DNA</tag>
        <tag>RNA-seq</tag>
      </tags>
  </entry>
  <entry>
    <title>scGPT</title>
    <url>/blog/2024/05/22/scGPT/</url>
    <content><![CDATA[<h1>scGPT模型及其在不同任务中的表现</h1>
<h2 id="作者使用的基准方法和对比方法在不同任务和指标上的表现">作者使用的基准方法和对比方法在不同任务和指标上的表现</h2>
<p>以下是作者在不同任务下使用的基准方法或对比方法，以及它们在相应指标上的表现总结：</p>
<h3 id="单细胞RNA测序数据的细胞类型注释">单细胞RNA测序数据的细胞类型注释</h3>
<ul>
<li><strong>基准方法</strong>: scBERT 和 TOSICA</li>
<li><strong>指标</strong>: 准确性(Accuracy)、精确度(Precision)、召回率(Recall)、宏F1分数(Macro F1)</li>
<li><strong>表现</strong>: 文章中未提供具体数值，但指出scGPT在所有分类指标上都优于这两种方法。</li>
</ul>
<h3 id="遗传扰动响应预测">遗传扰动响应预测</h3>
<ul>
<li><strong>对比方法</strong>: GEARS 和线性回归模型</li>
<li><strong>指标</strong>: Pearsondelta 和 Pearsondelta on differentially expressed genes (DE genes)</li>
<li><strong>表现</strong>: 文章中未提供具体数值，但强调scGPT在所有三个数据集上都取得了最高分，并且在预测扰动后变化的基因表达上，持续优于其他方法5-20%。</li>
</ul>
<h3 id="多批次scRNA-seq数据整合">多批次scRNA-seq数据整合</h3>
<ul>
<li><strong>对比方法</strong>: Seurat、Harmony 和 scVI</li>
<li><strong>指标</strong>: AvgBIO分数（包括NMIcell、ARIcell和ASWcell）、AvgBATCH分数（包括ASWbatch和GraphConn）</li>
<li><strong>表现</strong>: 文章中未提供具体数值，但指出scGPT在PBMC 10k数据集上的表现优于这些方法。</li>
</ul>
<h3 id="单细胞多组学数据整合">单细胞多组学数据整合</h3>
<ul>
<li><strong>对比方法</strong>: Seurat (v.4)、scGLUE 和 scMoMat</li>
<li><strong>指标</strong>: NMIcell、ARIcell、ASWcell、AvgBIO以及ASWbatch、GraphConn、AvgBATCH</li>
<li><strong>表现</strong>: 文章中未提供scGLUE和scMoMat的具体数值表现，但在10x Multiome PBMC数据集上，scGPT是唯一成功生成CD8+ naive细胞独特聚类的方法。在BMMC数据集上，scGPT比Seurat (v.4)展现出更明确的聚类结构。</li>
</ul>
<h3 id="基因调控网络推断">基因调控网络推断</h3>
<ul>
<li><strong>基准方法</strong>: 基于表达相关性的共表达网络</li>
<li><strong>指标</strong>: 未明确提及，但进行了路径富集分析以验证基因程序的质量</li>
<li><strong>表现</strong>: 文章中未提供共表达网络的具体数值表现，但指出scGPT在所有分辨率下识别的富集路径数量显著多于共表达方法。</li>
</ul>
<p>请注意，文章中并没有提供所有对比方法的具体数值表现，而是通过比较来强调scGPT在各个任务中的优越性能。为了获得其他方法的详细表现数据，可能需要查阅原始的基准测试或方法论文。</p>
<h1>scGPT模型验证采用的数据集</h1>
<p>作者在验证scGPT模型的有效性时，使用了多个数据集，并针对不同的任务和指标进行了评估。以下是使用的各个数据集、对应的任务以及评估所用的指标：</p>
<ol>
<li>
<p><strong>CELLxGENE scRNA-seq数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 用于构建全人类基础模型的预训练。</li>
<li><strong>指标</strong>: 未明确提及，但这是构建模型的基础数据集。</li>
</ul>
</li>
<li>
<p><strong>多发性硬化症(MS)数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 细胞类型注释。</li>
<li><strong>指标</strong>: 准确性(Accuracy)、精确度(Precision)、召回率(Recall)、宏F1分数(Macro F1)。</li>
</ul>
</li>
<li>
<p><strong>骨髓瘤(Myeloid)数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 细胞类型注释、遗传扰动响应预测。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>人类胰腺(Human Pancreas)数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 细胞类型注释。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>PBMC 10k数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 多批次scRNA-seq数据整合。</li>
<li><strong>指标</strong>: AvgBIO分数（包括NMIcell、ARIcell和ASWcell）、AvgBATCH分数（包括ASWbatch和GraphConn）。</li>
</ul>
</li>
<li>
<p><strong>周围皮层(Perirhinal Cortex)数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 多批次scRNA-seq数据整合。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>COVID-19数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 多批次scRNA-seq数据整合。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>Adamson、Norman和Replogle数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 遗传扰动响应预测。</li>
<li><strong>指标</strong>: Pearsondelta、Pearsondelta on differentially expressed genes (DE genes)。</li>
</ul>
</li>
<li>
<p><strong>10x Multiome PBMC数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 单细胞多组学(scMultiomic)数据整合。</li>
<li><strong>指标</strong>: NMIcell、ARIcell、ASWcell、AvgBIO以及ASWbatch、GraphConn、AvgBATCH。</li>
</ul>
</li>
<li>
<p><strong>BMMC数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 单细胞多组学数据整合。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>ASAP PBMC数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 单细胞多组学数据整合。</li>
<li><strong>指标</strong>: 同上。</li>
</ul>
</li>
<li>
<p><strong>免疫人类(Immune Human)数据集</strong>:</p>
<ul>
<li><strong>任务</strong>: 基因调控网络推断。</li>
<li><strong>指标</strong>: 未明确提及，但通过与已知生物学和功能组的一致性来验证网络的质量。</li>
</ul>
</li>
</ol>
<p>这些数据集覆盖了从基础模型预训练到各种下游应用的广泛任务，作者通过这些任务和指标全面评估了scGPT模型的性能。</p>
<h1>scGPT模型的验证</h1>
<p>文章中，作者为了验证模型scGPT的有效性，设计了多个下游任务，并使用了不同的方法和指标来衡量模型的表现情况。以下是各个下游任务、衡量方法和指标的总结：</p>
<ol>
<li>
<p><strong>单细胞RNA测序(cell type annotation)</strong>:</p>
<ul>
<li><strong>方法</strong>: 使用神经网络分类器对scGPT变换器输出的细胞嵌入进行分类，预测细胞类型。</li>
<li><strong>指标</strong>: 准确性(Accuracy)、精确度(Precision)、召回率(Recall)、宏F1分数(Macro F1)。</li>
<li><strong>意义</strong>: 这些指标评估了模型在细胞类型分类任务上的性能，包括整体的准确性、对每个类别的精确度和召回率，以及一个综合考虑类别权重的宏F1分数。</li>
<li><strong>结果</strong>: scGPT在多个数据集上的表现超过了其他方法，包括准确度、精确度、召回率和宏F1分数。</li>
</ul>
</li>
<li>
<p><strong>遗传扰动响应预测(Perturbation response prediction)</strong>:</p>
<ul>
<li><strong>方法</strong>: 使用Pearsondelta指标来衡量预测和观察到的扰动后基因表达变化之间的相关性。</li>
<li><strong>指标</strong>: Pearsondelta、Pearsondelta on differentially expressed genes（DE genes）。</li>
<li><strong>意义</strong>: 这些指标衡量了模型对于未见过的基因扰动响应的预测能力，特别是在预测最显著变化的基因上的表现。</li>
<li><strong>结果</strong>: scGPT在预测未见基因扰动响应的任务上取得了最高的分数，并且在所有三个数据集上都优于其他方法。</li>
</ul>
</li>
<li>
<p><strong>多批次scRNA-seq数据整合(Multi-batch scRNA-seq integration)</strong>:</p>
<ul>
<li><strong>方法</strong>: 使用scGPT进行自监督微调，学习统一的细胞表示以恢复掩蔽的基因表达。</li>
<li><strong>指标</strong>: AvgBIO分数（包括NMIcell、ARIcell和ASWcell）和AvgBATCH分数（包括ASWbatch和GraphConn）。</li>
<li><strong>意义</strong>: AvgBIO分数衡量了数据整合后细胞类型聚类与真实标签的一致性，而AvgBATCH分数衡量了批次效应校正的性能。</li>
<li><strong>结果</strong>: scGPT在PBMC 10k数据集上成功分离了所有细胞类型，并且在AvgBIO分数上比比较方法高出5-10%。</li>
</ul>
</li>
<li>
<p><strong>单细胞多组学(scMultiomic)数据整合</strong>:</p>
<ul>
<li><strong>方法</strong>: 对于配对和马赛克数据整合设置，scGPT与Seurat (v.4)、scGLUE和scMoMat等方法进行比较。</li>
<li><strong>指标</strong>: NMIcell、ARIcell、ASWcell、AvgBIO以及ASWbatch、GraphConn、AvgBATCH。</li>
<li><strong>意义</strong>: 这些指标评估了模型在整合不同组学数据时保持生物学信号和校正批次效应的能力。</li>
<li><strong>结果</strong>: scGPT在10x Multiome PBMC数据集上成功生成了CD8+ naive细胞的独特聚类，并且在BMMC数据集上展现了更明确的聚类结构。</li>
</ul>
</li>
<li>
<p><strong>基因调控网络推断(Gene regulatory network inference)</strong>:</p>
<ul>
<li><strong>方法</strong>: 使用scGPT嵌入和注意力图来推断基因调控网络。</li>
<li><strong>指标</strong>: 未明确提及，但通过与已知生物学和功能组的一致性来验证网络的质量。</li>
<li><strong>意义</strong>: 这些分析评估了scGPT在推断基因间复杂关系和特定细胞状态下的基因调控网络的能力。</li>
<li><strong>结果</strong>: scGPT能够通过学习到的基因嵌入和注意力图来揭示生物学上有意义的基因调控网络。</li>
</ul>
</li>
</ol>
<p>在所有这些任务中，scGPT模型都展现出了优越的性能，这表明了其在单细胞多组学数据建模方面的有效性和潜力。</p>
<h1>scGPT验证指标的表现</h1>
<p>在文章中，作者通过多个下游任务验证了scGPT模型的有效性，并在各项任务和指标上展示了其出色的表现：</p>
<ol>
<li>
<p><strong>单细胞RNA测序数据的细胞类型注释</strong>:</p>
<ul>
<li><strong>表现</strong>: scGPT在人类胰腺数据集上实现了高精确度(&gt;0.8)，并且在多边形混淆矩阵中，大多数细胞类型的预测结果准确。在疾病数据集（如多发性硬化症MS）上，scGPT模型在细胞类型注释上达到了约0.85的高准确率。在肿瘤浸润性髓系数据集上，scGPT在区分免疫细胞亚型方面表现出高精确度。</li>
</ul>
</li>
<li>
<p><strong>遗传扰动响应预测</strong>:</p>
<ul>
<li><strong>表现</strong>: 在三个Perturb-seq数据集上评估scGPT的扰动预测能力，scGPT在预测未见基因的扰动响应方面表现优异，通过Pearsondelta指标衡量，scGPT在所有数据集上都取得了最高分，特别是在预测扰动后变化的基因表达上，持续优于其他方法5-20%。</li>
</ul>
</li>
<li>
<p><strong>多批次scRNA-seq数据整合</strong>:</p>
<ul>
<li><strong>表现</strong>: 在COVID-19、PBMC 10k和周围皮层数据集上的整合性能评估中，scGPT在细胞类型聚类和批次效应校正方面展现出了优越的整合性能，AvgBIO分数比其他方法高出5-10%。</li>
</ul>
</li>
<li>
<p><strong>单细胞多组学数据整合</strong>:</p>
<ul>
<li><strong>表现</strong>: 在10x Multiome PBMC数据集上，scGPT是唯一成功生成CD8+ naive细胞独特聚类的方法。在BMMC数据集上，scGPT比Seurat (v.4)展现出更明确的聚类结构，并且在AvgBIO分数上提高了9%。</li>
</ul>
</li>
<li>
<p><strong>基因调控网络推断</strong>:</p>
<ul>
<li><strong>表现</strong>: scGPT能够成功识别与T细胞激活相关的基因群组，如编码T3复合体的CD3基因群，以及与B细胞信号传导和HLA类I分子的共受体相关的基因。在免疫人类数据集上，scGPT模型突出显示了与特定免疫细胞类型相关的CD基因网络。</li>
</ul>
</li>
</ol>
<p>总体而言，scGPT在所有这些任务中都展现出了卓越的性能，不仅在精确度、准确率、召回率和F1分数等指标上超越了其他方法，而且还能够揭示生物学上有意义的基因调控网络，证明了其在单细胞生物学和遗传研究中的潜力和应用价值。</p>
<h1>scGPT模型验证详情</h1>
<table>
<thead>
<tr>
<th>任务类型</th>
<th>任务描述</th>
<th>模型表现</th>
<th>评估指标</th>
<th>数据集</th>
<th>基准/对比方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>细胞类型注释</td>
<td>对单细胞RNA测序数据进行细胞类型的分类和注释</td>
<td>在人类胰腺数据集上实现高精确度(&gt;0.8)；在MS数据集上达到约0.85的准确率</td>
<td>准确性(Accuracy)、精确度(Precision)、召回率(Recall)、宏F1分数(Macro F1)</td>
<td>多发性硬化症(MS)数据集、人类胰腺数据集、骨髓瘤(Myeloid)数据集</td>
<td>scBERT、TOSICA</td>
</tr>
<tr>
<td>遗传扰动响应预测</td>
<td>预测基因扰动后的细胞响应</td>
<td>在三个Perturb-seq数据集上持续优于其他方法5-20%</td>
<td>Pearsondelta、Pearsondelta on DE genes</td>
<td>Adamson、Norman、Replogle数据集</td>
<td>GEARS、线性回归模型</td>
</tr>
<tr>
<td>多批次scRNA-seq数据整合</td>
<td>整合来自不同批次的单细胞RNA测序数据</td>
<td>在PBMC 10k数据集上成功分离所有细胞类型，AvgBIO分数比其他方法高出5-10%</td>
<td>AvgBIO分数（NMIcell、ARIcell、ASWcell）、AvgBATCH分数（ASWbatch、GraphConn）</td>
<td>COVID-19数据集、PBMC 10k数据集、周围皮层数据集</td>
<td>Seurat、Harmony、scVI</td>
</tr>
<tr>
<td>单细胞多组学数据整合</td>
<td>整合单细胞多组学数据</td>
<td>在10x Multiome PBMC数据集上成功生成CD8+ naive细胞独特聚类；在BMMC数据集上展现更明确聚类结构</td>
<td>NMIcell、ARIcell、ASWcell、AvgBIO、ASWbatch、GraphConn、AvgBATCH</td>
<td>10x Multiome PBMC数据集、BMMC数据集、ASAP PBMC数据集</td>
<td>Seurat (v.4)、scGLUE、scMoMat</td>
</tr>
<tr>
<td>基因调控网络推断</td>
<td>推断基因间的调控网络</td>
<td>能够揭示生物学上有意义的基因调控网络</td>
<td>未明确提及，通过与已知生物学和功能组的一致性来验证</td>
<td>免疫人类(Immune Human)数据集</td>
<td>基于表达相关性的共表达网络</td>
</tr>
</tbody>
</table>
<!-- # 数据集和基准/对比方法信息

| 数据集/方法 | 描述 | 链接/文章 |
|--------------|------|-----------|
| MS数据集     | 多发性硬化症相关的单细胞RNA测序数据集 | 待查询 |
| 人类胰腺数据集 | 人类胰腺细胞的单细胞RNA测序数据集 | 待查询 |
| Myeloid数据集 | 骨髓瘤相关的单细胞RNA测序数据集 | 待查询 |
| COVID-19数据集 | 与COVID-19相关的单细胞RNA测序数据集 | 待查询 |
| scBERT       | 用于细胞类型注释的基准方法 | 待查询 |
| TOSICA       | 用于细胞类型注释的基准方法 | 待查询 |
| GEARS        | 遗传扰动响应预测的对比方法 | 待查询 |
| Seurat       | 多批次数据整合的对比方法 | 待查询 |
| Harmony      | 多批次数据整合的对比方法 | 待查询 |
| scVI         | 多批次数据整合的对比方法 | 待查询 |
| scGLUE       | 单细胞多组学数据整合的对比方法 | 待查询 |
| scMoMat      | 单细胞多组学数据整合的对比方法 | 待查询 |

请注意，表格中的链接和文章列需要你根据上述指导自行查询和填写。

根据您提供的文件内容，我们可以创建一个表格，列出scGPT模型验证中使用的数据集、基准/对比方法以及相关的文献引用。请注意，由于我无法访问外部数据库来检索具体的文献链接，以下表格中的引用信息是基于您提供的文件内容整理的，您可能需要根据具体的文献引用去查找相应的文章和链接。 -->
<h1>scGPT模型验证中使用的数据集和基准/对比方法</h1>
<table>
<thead>
<tr>
<th>数据集</th>
<th>描述</th>
<th>文献引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CELLxGENE scRNA-seq数据集</td>
<td>用于构建全人类基础模型的预训练</td>
<td><a href="https://icbi-lab.github.io/cellxgene-user-guide/">cellxgene</a></td>
</tr>
<tr>
<td>MS数据集</td>
<td>多发性硬化症相关的单细胞RNA测序数据集</td>
<td><a href="https://www.ebi.ac.uk/gxa/sc/experiments/E-HCAD-35">E-HCAD-35</a></td>
</tr>
<tr>
<td>Myeloid数据集</td>
<td>骨髓瘤相关的单细胞RNA测序数据集</td>
<td><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154763">GSE154763</a></td>
</tr>
<tr>
<td>Human Pancreas数据集</td>
<td>人类胰腺细胞的单细胞RNA测序数据集</td>
<td><a href="https://github.com/JackieHanLab/TOSICA">TOSICA</a></td>
</tr>
<tr>
<td>PBMC 10k数据集</td>
<td>人类PBMC细胞的单细胞RNA测序数据集</td>
<td><a href="https://scvi-tools.org/">scVI tools</a></td>
</tr>
<tr>
<td>Perirhinal Cortex数据集</td>
<td>来自人脑皮层的单细胞数据集</td>
<td><a href="https://cellxgene.cziscience.com/">CELLxGENE Human Brain Cell Atlas</a></td>
</tr>
<tr>
<td>COVID-19数据集</td>
<td>与COVID-19相关的单细胞RNA测序数据集</td>
<td><a href="https://github.com/theislab/scarches-reproducibility">scarches-reproducibility</a></td>
</tr>
<tr>
<td>Adamson数据集</td>
<td>CRISPR干扰的基因表达数据集</td>
<td><a href="https://dataverse.harvard.edu/">哈佛数据集</a></td>
</tr>
<tr>
<td>Norman数据集</td>
<td>Perturb-seq技术得到的基因表达数据集</td>
<td><a href="https://dataverse.harvard.edu/">哈佛数据集</a></td>
</tr>
<tr>
<td>Replogle数据集</td>
<td>K562白血病细胞系的基因组范围扰动数据</td>
<td><a href="https://gwps.wi.mit.edu/">MIT数据集</a></td>
</tr>
<tr>
<td>10x Multiome PBMC数据集</td>
<td>单细胞多组学数据集</td>
<td><a href="https://scglue.readthedocs.io/en/latest/data.html">scGLUE</a></td>
</tr>
<tr>
<td>BMMC数据集</td>
<td>包含RNA和蛋白的单细胞多组学数据集</td>
<td><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE194122">GSE194122</a></td>
</tr>
<tr>
<td>ASAP PBMC数据集</td>
<td>包含多种数据模态的单细胞数据集</td>
<td><a href="https://github.com/PeterZZQ/scMoMaT/">scMoMaT</a></td>
</tr>
<tr>
<td>Immune Human数据集</td>
<td>用于基因调控网络推断的单细胞数据集</td>
<td><a href="https://doi.org/10.6084/m9.figshare.12420968.v8">Figshare</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>基准/对比方法</th>
<th>描述</th>
<th>评估指标</th>
<th>文献引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scBERT</td>
<td>用于细胞类型注释的基准方法</td>
<td>准确性(Accuracy)、精确度(Precision)、召回率(Recall)、宏F1分数(Macro F1)</td>
<td><a href="https://www.nature.com/articles/s42256-022-00534-z">scBERT</a></td>
</tr>
<tr>
<td>TOSICA</td>
<td>用于细胞类型注释的基准方法</td>
<td>同上</td>
<td><a href="https://www.nature.com/articles/s41467-023-35923-4">TOSICA</a></td>
</tr>
<tr>
<td>GEARS</td>
<td>遗传扰动响应预测的对比方法</td>
<td>Pearsondelta 和 Pearsondelta on differentially expressed genes (DE genes)</td>
<td><a href="https://www.nature.com/articles/s41587-023-01905-6">GEARS</a></td>
</tr>
</tbody>
</table>
<!-- | 线性回归模型 | 遗传扰动响应预测的对比方法 | 同上 | [文献引用待查询] | -->
<p>| Seurat        | 多批次scRNA-seq数据整合的对比方法 | AvgBIO分数（包括NMIcell、ARIcell和ASWcell）、AvgBATCH分数（包括ASWbatch和GraphConn） | <a href="https://www.nature.com/articles/nbt.3192">Seurat</a> |<br>
| Harmony       | 多批次scRNA-seq数据整合的对比方法 | 同上 | <a href="https://www.nature.com/articles/s41592-019-0619-0">Harmony</a> |<br>
| scVI          | 多批次scRNA-seq数据整合的对比方法 | 同上 | <a href="https://www.nature.com/articles/s41592-018-0229-2">scVI</a> |<br>
| scGLUE        | 单细胞多组学数据整合的对比方法 | NMIcell、ARIcell、ASWcell、AvgBIO以及ASWbatch、GraphConn、AvgBATCH | <a href="https://www.nature.com/articles/s41587-022-01284-4">scGLUE</a> |<br>
| scMoMat       | 单细胞多组学数据整合的对比方法 | 同上 | <a href="https://www.nature.com/articles/s41467-023-36066-2">scMoMat</a> |<br>
| coexpression network   | 基因调控网络推断的基准方法 | 未明确提及，但通过与已知生物学和功能组的一致性来验证 | <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-021-04179-4">coexpression network</a> |</p>
]]></content>
      <categories>
        <category>大模型</category>
        <category>生命科学</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Bio</tag>
        <tag>RNA-seq</tag>
        <tag>scGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>genePT</title>
    <url>/blog/2024/05/22/GenePT/</url>
    <content><![CDATA[<p>这篇文章介绍了一个名为GenePT的模型，该模型利用大型语言模型（如GPT-3.5）来生成基因和细胞的嵌入表示，以便于单细胞生物学分析。作者设计了一系列下游任务来验证GenePT模型的有效性，并与现有的单细胞基础模型（如Geneformer和scGPT）进行了比较。以下是文章中提到的下游任务、衡量方法、指标以及数据集的总结：</p>
<h3 id="模型复杂度">模型复杂度</h3>
<p>scGPT模型的具体参数数量没有直接提及。然而，文章中提到了模型的一些架构细节，例如：</p>
<ol>
<li>预训练基础模型: 嵌入大小为512，包含12个堆叠的变换器块（transformer blocks），每个块有8个注意力头（attention heads）。</li>
<li>全连接层: 隐藏层大小为512。</li>
</ol>
<h3 id="下游任务：">下游任务：</h3>
<ol>
<li><strong>基因功能类别预测</strong>：预测基因属于的最常见的15个功能类别之一。</li>
<li><strong>基因属性预测</strong>：包括区分剂量敏感与不敏感的转录因子、区分不同的基因甲基化状态等。</li>
<li><strong>基因-基因相互作用预测</strong>：预测两个基因是否相互作用。</li>
<li><strong>蛋白质-蛋白质相互作用预测</strong>：预测两个蛋白质之间是否存在相互作用。</li>
<li><strong>细胞类型注释</strong>：基于细胞的嵌入表示预测细胞的类型。</li>
<li><strong>批次效应评估</strong>：评估嵌入表示在去除批次效应的同时保留生物学信息的能力。</li>
</ol>
<h3 id="衡量方法和指标：">衡量方法和指标：</h3>
<ul>
<li><strong>准确率（Accuracy）</strong>：正确预测的数量除以总预测数量。</li>
<li><strong>精确度（Precision）</strong>：正确预测为正的数量除以预测为正的总数量。</li>
<li><strong>召回率（Recall）</strong>：正确预测为正的数量除以实际为正的总数量。</li>
<li><strong>F1分数</strong>：精确度和召回率的调和平均值，衡量模型的准确性和完整性的平衡。</li>
<li><strong>ROC-AUC</strong>：接收者操作特征曲线下的面积，衡量分类器在所有可能的分类阈值上的性能。</li>
<li><strong>Adjusted Rand Index (ARI)</strong> 和 <strong>Adjusted Mutual Information (AMI)</strong>：评估聚类结果与真实标签之间的一致性。</li>
</ul>
<h3 id="作者的指标表现：">作者的指标表现：</h3>
<p>文章中提到GenePT在多个任务上的表现与Geneformer和其他模型相当，甚至在一些任务上表现更好。</p>
<h4 id="Gene功能类别预测：">Gene功能类别预测：</h4>
<ul>
<li><strong>GenePT</strong>：整体准确率达到96%，类具体准确度和只有小幅度的误分类。</li>
</ul>
<h4 id="基因-基因相互作用预测-GGI-：">基因-基因相互作用预测 (GGI)：</h4>
<ul>
<li><strong>GenePT</strong>：使用共享基因本体 (GO) 注释的测试GGI数据集，ROC-AUC为0.82。</li>
</ul>
<h4 id="蛋白质-蛋白质相互作用预测-PPI-：">蛋白质-蛋白质相互作用预测 (PPI)：</h4>
<ul>
<li><strong>GenePT</strong>：在三个不同的PPI数据集上，ROC-AUC分别为：
<ul>
<li>文献衍生数据集：ROC-AUC未明确给出，但提到表现优于其他模型。</li>
<li>综合检测数据集：ROC-AUC未明确给出，但提到表现优于其他模型。</li>
<li>组织特异性蛋白质-蛋白质功能网络数据集：ROC-AUC未明确给出，但提到表现优于其他模型。</li>
</ul>
</li>
</ul>
<h4 id="细胞类型注释：">细胞类型注释：</h4>
<ul>
<li><strong>GenePT-w</strong> 和 <strong>GenePT-s</strong> 在多个数据集上的表现与 <strong>scGPT</strong> 和 <strong>Geneformer</strong> 相比较：
<ul>
<li><strong>Aorta 数据集</strong>：
<ul>
<li>GenePT-w: ARI=0.12, AMI=0.12, ASW=0.01</li>
<li>GenePT-s: ARI=0.09, AMI=0.12, ASW=-0.04</li>
</ul>
</li>
<li><strong>Artery 数据集</strong>：
<ul>
<li>GenePT-w: ARI=0.47, AMI=0.64, ASW=0.18</li>
<li>GenePT-s: ARI=0.36, AMI=0.59, ASW=0.15</li>
</ul>
</li>
<li><strong>Bones 数据集</strong>：
<ul>
<li>GenePT-w: ARI=0.12, AMI=0.21, ASW=-0.01</li>
<li>GenePT-s: ARI=0.21, AMI=0.29, ASW=0.02</li>
</ul>
</li>
<li><strong>Myeloid 数据集</strong>（癌症类型）：
<ul>
<li>GenePT-w: ARI=0.25, AMI=0.27, ASW=0.02</li>
<li>GenePT-s: ARI=0.17, AMI=0.17, ASW=0.06</li>
</ul>
</li>
<li><strong>Pancreas 数据集</strong>：
<ul>
<li>GenePT-w: ARI=0.49, AMI=0.69, ASW=0.15</li>
<li>GenePT-s: ARI=0.30, AMI=0.50, ASW=0.10</li>
</ul>
</li>
<li><strong>Multiple Sclerosis 数据集</strong>（年龄）：
<ul>
<li>GenePT-w: ARI=0.07, AMI=0.13, ASW=-0.07</li>
<li>GenePT-s: ARI=0.06, AMI=0.12, ASW=-0.03</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="批次效应评估：">批次效应评估：</h4>
<ul>
<li><strong>GenePT</strong> 在去除批次效应的同时保留生物学信息的能力表现良好，与 <strong>scGPT</strong> 和 <strong>Geneformer</strong> 相比，在多个数据集上的ARI值降低，表明批次效应较小。</li>
</ul>
<blockquote>
<p>ARI和AMI用来衡量聚类结果与真实标签之间的一致性，ASW用来评估聚类结果的凝聚度和分离度。<br>
GenePT在多数任务中展现出与现有模型相当的或更好的性能。</p>
</blockquote>
<h3 id="数据集：">数据集：</h3>
<ul>
<li><strong>基因功能类别预测</strong>：使用特定的基因功能类别数据集（geneformer）。</li>
<li><strong>基因属性预测</strong>：使用Theodoris等人提供的开源数据。</li>
<li><strong>基因-基因相互作用预测</strong>：使用Du等人基于共享基因本体注释的基准数据集。</li>
<li><strong>蛋白质-蛋白质相互作用预测</strong>：使用了多个数据集，包括HuRI、Lit-BM和Greene等人提供的组织特异性蛋白质-蛋白质功能网络。</li>
<li><strong>细胞类型注释</strong>：使用了来自循环系统（Aorta、Artery）、骨组织（Bones、Myeloid）、胰腺和来自健康个体以及多发性硬化症患者的免疫细胞的数据集。</li>
</ul>
<h3 id="基准方法和对比方法：">基准方法和对比方法：</h3>
<p>文章中提到了Geneformer和scGPT作为基准方法。这些方法在不同的任务和指标上的表现被用来与GenePT进行比较。具体的数值表现和比较分析可能在文章的实验部分有详细说明。</p>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th>任务类型</th>
<th>指标</th>
<th>GenePT表现</th>
<th>数据集名称</th>
<th>基准/对比方法</th>
<th>引用链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gene Functionality Class Prediction</td>
<td>Accuracy</td>
<td>96%</td>
<td>-</td>
<td>Geneformer等</td>
<td>-</td>
</tr>
<tr>
<td>Gene Property Prediction Tasks</td>
<td>Various</td>
<td>未具体说明</td>
<td>-</td>
<td>Gene2vec, scGPT</td>
<td><a href="https://www.nature.com/articles/s41586-023-05903-5">Theodoris et al. 2023</a></td>
</tr>
<tr>
<td>Gene-Gene Interaction Prediction</td>
<td>ROC-AUC</td>
<td>0.82</td>
<td>GEO expression data</td>
<td>Gene2vec/scGPT/Geneformer</td>
<td><a href="https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-5977-5">Du et al. 2019</a></td>
</tr>
<tr>
<td>Protein-Protein Interaction Prediction</td>
<td>ROC-AUC</td>
<td>未明确给出，但优于其他模型</td>
<td>HuRI, Lit-BM, Tissue-specific PPI networks</td>
<td>Other models</td>
<td><a href="https://www.nature.com/articles/nature5803-402">HuRI dataset</a>, <a href="https://www.cell.com/cell/fulltext/S0092-8674(14)01212-6">Lit-BM dataset</a>, <a href="https://www.nature.com/articles/ng.3295">Tissue-specific PPI networks</a></td>
</tr>
<tr>
<td>Cell Type Annotation</td>
<td>ARI, AMI, ASW</td>
<td>根据不同数据集而异</td>
<td>Aorta, Artery, Bones等</td>
<td>scGPT, Geneformer</td>
<td><a href="https://www.nature.com/articles/nature608174">Chaffin et al. 2022</a>, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7232955/">Li et al. 2020</a></td>
</tr>
<tr>
<td>Batch Effect Assessment</td>
<td>ARI</td>
<td>降低，表明批次效应较小</td>
<td>Cardiomyocyte dataset, Aorta dataset</td>
<td>Geneformer, scGPT</td>
<td><a href="https://www.ebi.ac.uk/gxa/home">Chaffin et al. dataset</a>, <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE149769">Li et al. dataset</a></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>大模型</category>
        <category>生命科学</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Bio</tag>
        <tag>RNA-seq</tag>
        <tag>GenePT</tag>
      </tags>
  </entry>
  <entry>
    <title>在GCP上建立虚拟机实例</title>
    <url>/blog/2024/05/25/%E5%9C%A8GCP%E4%B8%8A%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1>创建实例</h1>
<p>进入<a href="https://console.cloud.google.com/">GCP网页</a>后，会自动跳转到对应的项目的欢迎页下，如图所示：</p>
<p><img src="welcome.png" alt="welcome"></p>
<p>随后点击<strong>Create a VM</strong>进入建立实例的页面，如图所示：</p>
<p><img src="create_vm.png" alt="Create Virtual Machine"></p>
<p>在这里，根据自己的需要选择合适的区域、机器配置、启动磁盘，设置对应的身份和 API 访问权限、防火墙、高级选项-网络等。</p>
<p>设置好后，就点击<strong>创建</strong>。</p>
<blockquote>
<p>值得注意的是，有时会在<strong>每月估算费用</strong>那里显示<strong>缺少额度</strong>，只要点击下面的<em>申请</em>就可以了，一般10分分钟内就能通过请求。</p>
<p>在选择机器时，GPU的配置往往时重点，这个<a href="https://cloud.google.com/compute/docs/gpus/gpu-regions-zones?hl=zh-cn">表格</a>展示了GCP在不同区域提供的GPU的型号。</p>
</blockquote>
<p>如此一来就可以在<strong>虚拟机实例</strong>界面中看到自己建立的vm了，如图：</p>
<p><img src="vm.png" alt="vm"></p>
<h1>ssh 连接</h1>
<h2 id="web连接">web连接</h2>
<p>在建立好vm后，就可以使用ssh和vm连接了，这也很简单，如图所示：</p>
<p><img src="sshweb.png" alt="ssh web"></p>
<p>只要点击<strong>在浏览器窗口打开</strong>就可以进入到vm中，如图所示：</p>
<p><img src="sshwebnvidia.png" alt="ssh web nvidia"></p>
<blockquote>
<p>这里因为我需要使用GPU所以选择了预装了nvidia和cuda的<strong>映像</strong></p>
</blockquote>
<p>最后虽然出现了这样的警告，但是不影响正常的使用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">WARNING: <span class="title">The</span> <span class="title">nvidia</span>-<span class="title">drm</span> <span class="title">module</span> <span class="title">will</span> <span class="title">not</span> <span class="title">be</span> <span class="title">installed</span>. <span class="title">As</span> <span class="title">a</span> <span class="title">result</span>, <span class="title">DRM</span>-<span class="title">KMS</span> <span class="title">will</span> <span class="title">not</span></span></span><br><span class="line"><span class="function">         <span class="title">function</span> <span class="title">with</span> <span class="title">this</span> <span class="title">installation</span> <span class="title">of</span> <span class="title">the</span> <span class="title">NVIDIA</span> <span class="title">driver</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">WARNING</span>: <span class="title">nvidia</span>-<span class="title">installer</span> <span class="title">was</span> <span class="title">forced</span> <span class="title">to</span> <span class="title">guess</span> <span class="title">the</span> <span class="title">X</span> <span class="title">library</span> <span class="title">path</span> &#x27;/<span class="title">usr</span>/<span class="title">lib64</span>&#x27; <span class="title">and</span> <span class="title">X</span></span></span><br><span class="line"><span class="function">         <span class="title">module</span> <span class="title">path</span> &#x27;/<span class="title">usr</span>/<span class="title">lib64</span>/<span class="title">xorg</span>/<span class="title">modules</span>&#x27;; <span class="title">these</span> <span class="title">paths</span> <span class="title">were</span> <span class="title">not</span> <span class="title">queryable</span> <span class="title">from</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">         <span class="title">system</span>.  <span class="title">If</span> <span class="title">X</span> <span class="title">fails</span> <span class="title">to</span> <span class="title">find</span> <span class="title">the</span> <span class="title">NVIDIA</span> <span class="title">X</span> <span class="title">driver</span> <span class="title">module</span>, <span class="title">please</span> <span class="title">install</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">         `<span class="title">pkg</span>-<span class="title">config</span>` <span class="title">utility</span> <span class="title">and</span> <span class="title">the</span> <span class="title">X.Org</span> <span class="title">SDK</span>/<span class="title">development</span> <span class="title">package</span> <span class="title">for</span> <span class="title">your</span> <span class="title">distribution</span></span></span><br><span class="line"><span class="function">         <span class="title">and</span> <span class="title">reinstall</span> <span class="title">the</span> <span class="title">driver</span>.</span></span><br></pre></td></tr></table></figure>
<p>使用<code>nvidia-smi</code>也可以正常的显示，如图：</p>
<p><img src="nvidia.png" alt="nvidia-smi"></p>
<p>随后就可以正常的开展自己的任务了。</p>
<h2 id="本地连接">本地连接</h2>
<p>web连接虽然很方便，但是因为我习惯使用<code>vscode</code>作为编辑器，并且在<code>tmux</code>中运行程序，所以，我需要把vm和本机🔗起来。而这也不难实现，只要建立好<strong>ssh密钥-公钥</strong>就好。</p>
<h3 id="本地生成ssh密钥-公钥">本地生成ssh密钥-公钥</h3>
<p>进入<code>Terminal</code>，在windows上就是<code>windows powershell</code>，输入<code>cd ~/.ssh</code>进入了<code>.ssh</code>文件夹中。</p>
<p>然后输入<code>ssh-keygen -t rsa -f ~/.ssh/gcp_test -C [user_name]</code>，这里的<code>user_name</code>就是你的gcp的用户名，也就是从web登录后的<code>xxx@mmm</code>中的<code>xxx</code>；随后会要求你输入一个保存的文件名，不妨设置为<code>gcp_test</code>。</p>
<p>随后，设置<code>.ssh</code>中的<code>config</code>文件以方便使用ssh来连接vm:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host gcp-test</span><br><span class="line">  HostName xx.xxx.xxx.xxx   # vm的外部ip地址，每次开机都会发生改变</span><br><span class="line">  User user_name # vm上的用户名</span><br><span class="line">  IdentityFile ~/.ssh/gcp_test  # 私钥的保存路径</span><br><span class="line">  LocalForward 6006 localhost:6006  # 本地的映射接口</span><br></pre></td></tr></table></figure>
<h3 id="远程设置公钥">远程设置公钥</h3>
<p>然后输入<code>cat gcp_test.pub</code>来显示公钥，然后复制公钥。进入<strong>元数据</strong>，点击<em>SSH密钥</em>、<em>修改</em>，如图所示：</p>
<p><img src="madata.png" alt="ma data"></p>
<p>把自己的公钥复制其中。</p>
<p>或者，通过web设置公钥：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">nano authorized_keys</span><br><span class="line"># 然后就是把公钥复制其中</span><br><span class="line"># ctrl+O 保存</span><br><span class="line"># enter 确认</span><br><span class="line"># ctrl+x 退出</span><br></pre></td></tr></table></figure>
<p>然后输入命令<code>ssh gcp-test</code>，连接到vm</p>
<h2 id="连接到GitHub">连接到GitHub</h2>
<p>为了工作方便，我需要使用GitHub+git来同步。</p>
<h3 id="在vm中建立ssh">在vm中建立ssh</h3>
<p>为了连接GitHub，我需要在vm中建立一个ssh私钥-公钥对：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C &quot;your github email&quot;</span><br></pre></td></tr></table></figure>
<p>我是直接全部<code>enter</code>也就是使用默认的文件路径并且不设置密码。</p>
<h3 id="公钥部署到GitHub">公钥部署到GitHub</h3>
<p>然后，使用<code>cat id_rsa.pub</code>，显示了对应的公钥；进入GitHub中的<a href="https://github.com/settings/ssh/new">ssh页面</a>。把刚才复制的内容粘贴进去，并且起一个名字就好。</p>
<p>随后使用<code>ssh -T git@github.com</code>确认是不是成功连接到GitHub。</p>
<blockquote>
<p>如此一来就实现了在本地对vm的连接并且连接vm到GitHub上</p>
</blockquote>
<h1>下载一些软件</h1>
<p>在Linux中下载和安装<code>aria2c</code>、<code>wget</code>和<code>git-lfs</code>可以通过包管理器进行。以下是具体步骤：</p>
<h2 id="安装aria2c">安装<code>aria2c</code></h2>
<p><code>aria2c</code>是一个轻量级的多协议、多来源的命令行下载工具。</p>
<h3 id="Debian-Ubuntu">Debian/Ubuntu</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install aria2</span><br></pre></td></tr></table></figure>
<h3 id="CentOS-RHEL">CentOS/RHEL</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install aria2</span><br></pre></td></tr></table></figure>
<h3 id="Fedora">Fedora</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install aria2</span><br></pre></td></tr></table></figure>
<h2 id="安装wget">安装<code>wget</code></h2>
<p><code>wget</code>是一个命令行下载工具，支持HTTP、HTTPS和FTP协议。</p>
<h3 id="Debian-Ubuntu-2">Debian/Ubuntu</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install wget</span><br></pre></td></tr></table></figure>
<h3 id="CentOS-RHEL-2">CentOS/RHEL</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install wget</span><br></pre></td></tr></table></figure>
<h3 id="Fedora-2">Fedora</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install wget</span><br></pre></td></tr></table></figure>
<h2 id="安装git-lfs">安装<code>git-lfs</code></h2>
<p><code>git-lfs</code>（Git Large File Storage）是Git的扩展，专门用于处理大文件。</p>
<h3 id="Debian-Ubuntu-3">Debian/Ubuntu</h3>
<ol>
<li>
<p>安装必要的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git-lfs</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加Git LFS仓库并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="CentOS-RHEL-3">CentOS/RHEL</h3>
<ol>
<li>
<p>安装必要的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install curl</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加Git LFS仓库并安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum install git-lfs</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Fedora-3">Fedora</h3>
<ol>
<li>添加Git LFS仓库并安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash</span><br><span class="line">sudo dnf install git-lfs</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="验证安装">验证安装</h2>
<p>安装完成后，你可以使用以下命令验证各个工具是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aria2c --version</span><br><span class="line">wget --version</span><br><span class="line">git lfs --version</span><br></pre></td></tr></table></figure>
<p>如果输出了相应的版本信息，则说明安装成功。</p>
<h2 id="使用示例">使用示例</h2>
<ul>
<li>
<p><strong>aria2c</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aria2c http://example.com/file.zip</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>wget</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://example.com/file.zip</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>git-lfs</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git lfs track <span class="string">&quot;*.psd&quot;</span></span><br><span class="line">git add .gitattributes</span><br><span class="line">git add file.psd</span><br><span class="line">git commit -m <span class="string">&quot;Add design file&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过以上步骤，你应该能够在Linux系统中成功安装并使用<code>aria2c</code>、<code>wget</code>和<code>git-lfs</code>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Deep Learning</tag>
        <tag>Virtual Machine</tag>
        <tag>ssh</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习入门</title>
    <url>/blog/2024/06/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>前言</h1>
<h2 id="问题引入">问题引入</h2>
<p>想想一下，你正在研究一款新药，不妨为它起一个名字就叫“新-二甲双胍”。在药物的研制过程中，你想研究一些药物的摄入量和其药效之间的关系；为了简单起见，你把药物的服用的质量-体重比（g/kg）作为其摄入量；把服药后1h的血糖（mmol/L）作为药效的衡量指标；并且认为0.45-0.50mmol/L属于正常范围。</p>
<p>随后，你开展了一系列实验得到了下面这张图：</p>
<p><img src="%E5%AE%9E%E9%AA%8C.svg" alt="实验结果"></p>
<p>自然的，会希望使用某一种解析式来描述这个曲线；而且进一步的会希望使用最少的参数就能确定这个曲线。一个简单的想法是使用<strong>分段的线性拟合</strong>，其效果大约像这样：</p>
<p><img src="%E5%88%86%E6%AE%B5%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88.png" alt="分段-线性拟合"></p>
<p>很显然，这样的方法虽然使用的<strong>参数比较少</strong>，但是需要确定<strong>拐点</strong>，也就是实现不同线性函数之间的切换，这似乎不是一件容易的的事情。</p>
<blockquote>
<p>当然了，我们也可以使用伟大的<strong>多项式拟合</strong>但是这种方法其实也不是很好，如果有做过<em>大雾实验</em>就这知道这种方法比较容易过拟合，也就是在某些点总是得到不很好的拟合。如果在低维中就出现了这种问题，自然不能指望在高维中也有很好的效果。<br>
这里仅仅是顺戈一击，不要太在意</p>
</blockquote>
<p>但是，如果有方法可以自动地帮助<strong>线性函数变弯</strong>；那么，使用线性函数的拟合，就是一个好主意了。幸运的是，这不是什么困难的事情！</p>
<blockquote>
<p>这里的“变弯”仅仅是一种“图像”上的说法，更合适的说法是，调节不同的线性函数在不同范围上的对“总和”的贡献的大小。</p>
</blockquote>
<h2 id="拟合曲线">拟合曲线</h2>
<p>事实上，仅仅需要一些简单的线性函数和非线性函数，我们就可以很轻松的实现对这个曲线的拟合，如下图所示：</p>
<p><img src="%E5%88%86%E6%AD%A5%E8%A7%A3%E9%87%8A.png" alt="alt text"></p>
<p>这里的蓝色和红色分布表示一个线性变化和一个非线性变化，我们是通过对应的线性函数和非线性函数实现的这种变化；特别的是，这里使用的非线性函数是一个<strong>sigmoid</strong>函数。这里我没有标注每一个线性变化中的参数，因为具体的参数是什么在这里并不重要，我们只要能从图中的纵坐标的变化上是可以看出对应的线性变化的发生就可以了。</p>
<p>需要指出的是，这里的sigmoid函数的形式是：$\sigma(x) = \frac{1}{1 + \mathrm{e}^{-x}}$，也就是说，它的参数都是固定的、已知的。而线性函数:$y = \mathrm{w} \cdot x + \mathrm{b}$中的$\mathrm{w}$和$\mathrm{b}$则是不知道的，是需要确定的。</p>
<p>这里，我们先不考虑这里的$\mathrm{w}$和$\mathrm{b}$是怎么确定的，而是深入的考察一下上图到底在干啥，这样的一个拟合的过程要怎么理解。</p>
<h1>抽象化</h1>
<blockquote>
<p>这里是为了后面讨论的方法，主要是为了引入<strong>张量</strong>这件事</p>
</blockquote>
<h2 id="神经网络与曲线拟合">神经网络与曲线拟合</h2>
<p>正如我们上文讨论的那样，对一个曲线的拟合事实上可以通过一些线性运算和非线性运算的叠加。而神经网络中所发生的就是这样的运算，如下图所示：</p>
<blockquote>
<p>这里是强调<strong>forward</strong>中发生的事情，<strong>backward</strong>先不着急 ＞︿＜</p>
</blockquote>
<p><img src="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88.png" alt="神经网络与曲线拟合"></p>
<p>这里给出了一个简单的神经网络<strong>SimpleMLP</strong>，其内部结构事实上就是两个线性层，<code>fc1</code>和<code>fc2</code>，两个非线层，<code>sigmoid1</code>和<code>softmax</code>，一起形成的。输入的数据会依次经过：<code>fc1</code>&gt;<code>sigmoid1</code>&gt;<code>fc2</code>&gt;<code>softmax</code>，得到最后的输出。</p>
<p>这就是多层感知机<strong>MLP</strong>的基本结构，而MLP是现代神经网络的最基本的形式。</p>
<p>这里，我们不妨先把这个<code>fc1</code>&gt;<code>sigmoid1</code>&gt;<code>fc2</code>&gt;<code>softmax</code>的过程视作“某种变化”，也就是“一个黑箱”，我们只要输入一系列的数据，就能得到一系列的输出，而得到的输出正好和现实中的结果对的上号！如下图所示：</p>
<p><img src="%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA.png" alt="输入与输出"></p>
<blockquote>
<p>这里仅仅是用作示意，不要真的去观察箭头和数字是不是对的上哦🤣</p>
</blockquote>
<p>所以，我们到这里就知道了，我们事实上可以把一个神经网络看作一系列线性函数和非线性函数逐次作用的结果。但是，总是使用这样的语言来描述一个神经网络总是不方法的，特别是，在研究网络优化和复杂网络上。所以下面我们希望引入一种更加抽象、通用的方法来描述其中发生的事情。</p>
<h2 id="神经网络与张量">神经网络与张量</h2>
<blockquote>
<p>标量是零维的张量、向量/矢量是一维的张量、矩阵是二维的张量；这里指出，是希望下文不会引发什么歧义</p>
</blockquote>
<p>线性代数教会我们的一个重要的事情就是：<strong>一个线性变化，可以用一个矩阵运算来表示</strong>，我们在学习的过程中经常干的一件事情就是用输入的向量和输出的向量来确定中间的转化矩阵。那么，如果我们先忽略神经网络中的那些非线性的部分，我们就会意识到，它们是一回事情。也就是说，我们可以用张量之间的运算代替神经网络中的线性部分的运算。</p>
<blockquote>
<p>这里使用张量，是因为虽然我们学习线性代数时候总是见到向量和矩阵上的运算，但是现实中的数据总是高维的，比如图片，不用张量就难以描述。而且张量的运算的规律和它们是一样的。</p>
</blockquote>
<p>那么非线性的部分要怎么解决呢？其实也很简单，我们使用逐元素的运算就可以了，所以，非线性运算就是对张量进行逐元素的运算；特别的，这里的元素应该是一个单射，也就是一个输入只能有一个唯一的输出。</p>
<p>希望下面这张图可以帮助你理解这个过程：</p>
<p><img src="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%BC%A0%E9%87%8F.png" alt="神经网络与张量"></p>
<p>这里，我们把原本的线性运算使用张量之间的点乘代替；把原本的非线性运算用对张量的逐元素运算代替。解释了如何从输入$\mathbf{\vec{x^0}} \in \mathbb{R}^n$得到对应的预测$\mathbf{\vec{y^0}} \in \mathbb{R}^m$</p>
<p>值得注意的是，对一个神经网络可以有多个输入以及多个输出，而每一个输入或者输出可以是高维的信息（这往往意味着一个很长的向量）。</p>
<h1>小结</h1>
<p>综上所述，我们知道了神经网络在一定程度上和曲线拟合是一回事情；并且为了更好的描述其中的过程，也是为了应对高维和复杂网络的挑战，我们使用张量的语言来描述神经网络中的运算。这样一来，我们就已经描述了一个神经网络的<strong>forward</strong>也就是正向传播的过程。</p>
<p>但是，我们还没有解释神经网络中的那些未知的线性运算的参数，也就是那些张量$\mathbf{W}$和$\mathbf{b}$是怎么确定的。因为它们显然是经过仔细选择的，不然的话，预测得到的曲线怎么会和真实的曲线一致。而这些就是反向传播（backward）的过程了。</p>
<p>而且，我们还应该认识到，虽然我在这里给出的“引子”的输入是一个标量，但是事实上的输入是一个<strong>张量</strong>。也就是说，它是一个高维的信息，比如说一个512*512的RGB图像，它里面就有262114个像素而每一个像素有3个数字控制对应的三通道的值，也就是说，为了完整的描述这个图像应该需要786432个参数。而这仅仅是一个图像而已，现实中的图像更是数以亿计。</p>
<p>这样一来，考虑到线性方程求解的时候的要求，我们的网络也会需要大量的参数，也就是那些$\mathbf{W}$和$\mathbf{b}$。这样，如何高效的优化这些参数，使得它们可以很好的捕捉输入和输出之间的关系，就是紧要之处了。</p>
<p>而<strong>backward</strong>正是对这个问题的回答！</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>反向传播</title>
    <url>/blog/2024/06/09/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<h1>前言</h1>
<blockquote>
<p>横看成岭侧成峰，远近高低各不同。不识庐山真面目，只缘身在此山中。</p>
</blockquote>
<p>上一次我们谈到了求解线性方程，这个事情早在小学的鸡兔同笼上我们就已经在学习了，可是我们但是关注的是怎么“得到方程组的解”，也就是怎么从“头和脚的数量得到鸡和兔的数量”：</p>
<!-- $$
\begin{cases}
\mathbf{A}\mathbf{x} = \mathbf{b} \\
\mathbf{A}\mathbf{y} = \mathbf{b}'
\end{cases}
$$ -->
<p>$$<br>
\begin{bmatrix}<br>
a_{11} &amp; a_{12} \<br>
a_{21} &amp; a_{22}<br>
\end{bmatrix}<br>
\begin{bmatrix}<br>
x_{1} \<br>
x_{2}<br>
\end{bmatrix}<br>
=\begin{bmatrix}<br>
b_{1} \<br>
b_{2}<br>
\end{bmatrix}<br>
$$</p>
<p>上面方程组的矩阵形式的表达就是：</p>
<p>$$<br>
\mathbf{A}\mathbf{x} = \mathbf{b}<br>
$$</p>
<p>当时，我们已知的是$\mathbf{A}$和$\mathbf{b}$需要得到的是$\mathbf{x}$。</p>
<p>但是，当我们学习线性代数的时候，我们会发现这里的$\mathbf{A}$的性质才是我们真正关心的。也就是说，一个线性空间是如何映射到另一个线性空间的过程是我们正常关心的问题，而不是原空间和映射后空间中的几个点的性质。</p>
<p>和上一节相比，我们这一节也需要类似的思想上的转变。</p>
<h1>关注参数</h1>
<p>在上一节中，我们实现了使用张量的语言对最简单的神经网络——多层感知机（MLP）的描述：$\mathbf{\vec{y^0}} \in \mathbb{R}^m = \mathbb{f}(\mathbf{\vec{x^0}} \in \mathbb{R}^n) = sigmoid^i(fc^i(\mathbf{\vec{x^0}} ))=sigmoid^i(\mathbf{W^i}\cdot(\mathbf{\vec{x^0}}) + \mathbf{b^i})$。</p>
<p>上一节已经说过了，这里的sigmoid函数是$\sigma(x) = \frac{1}{1 + \mathrm{e}^{-x}}$，它的一起都是确定的所以，上面的MLP还可以换一种表达，也就是$\mathbf{\vec{y^0}} \in \mathbb{R}^m = \mathbb{g}(\mathbf{\vec{x^0}}, \mathbf{W, b}), \mathbf{\vec{x^0}} \in \mathbb{R}^n$。这里的$W,b$都是需要学习的参数，这里可以把它们统称为$\theta$。</p>
<p>所以，上面的表示的最简洁形式就是$\hat{Y} = F(X, \theta), \hat{Y} \in R^{(s,m)}, X \in R^{(s, n)}$。这里的$F$表示一种<strong>隐函数</strong>，这种函数没有显式的表达形式，在神经网络的语言下，它是人类的抽象思维，神经网络就要要学习这样的一个函数；这里的$s$是数据库中的数据的数量，$n$是输入的维度，$m$是输出的维度。</p>
<p>对一个神经网络来说，它的输入和输出，也就是$X$和$\hat{Y}$，都是确定的，它需要做的就是学习一个<strong>合适</strong>的$\theta$。</p>
<p>综上，这一节，我们需要关注的就是这里的$\theta$!</p>
<h1>合适的<strong>度量</strong></h1>
<p>上面我们提到了<strong>合适的$\theta$</strong>，那么要如何量化这里的“合适”？</p>
<h2 id="熵与信息熵">熵与信息熵</h2>
<blockquote>
<p>刑不可知，威不可测。<br>
信息也是这样，知道的越多，信息就越有序，它的“威”就是可以预测的；知道的越少，信息就越混乱，它就是不可测的“刑”。<br>
虽然“熵”的概念是西方人提出的，但是东方的政治家似乎很早就意识到信息熵中的力量 。。。</p>
</blockquote>
<ol>
<li>熵是一个物理学概念，它表示一个系统的不确定性程度，也就是一个系统的混乱程度。</li>
<li>信息熵：香农将熵引入信息论中，用来衡量信息的不确定性</li>
<li>二者是同样的内涵在不同的领域的应用</li>
</ol>
<h2 id="信息熵">信息熵</h2>
<h3 id="性质">性质</h3>
<ol>
<li>越不可能发生的事情，信息量越大；反之，必定会发生的事，信息为0</li>
<li>信息量越大，信息熵也越大</li>
<li>几个独立事件同时发生的信息量=每一个事件的信息量之和</li>
</ol>
<h3 id="定义">定义</h3>
<p>首先，使用对数函数来定义<strong>信息量</strong>，其中$P(x)$为事件发生的概率：<br>
$$<br>
I(x) = -log(P(x))<br>
$$</p>
<p>这里我们看看$I(x)$是不是符合上面的性质的要求：</p>
<ol>
<li>当一件事情必然发生时，$P(x)=1$，对应的$I(x)=0$，就是没有信息量</li>
<li>当一件事不可能发生时，$P(x)=0$，对应的$I(x)=+\infty$，也就是信息量很大</li>
<li>当有n件<strong>独立事件</strong>
<ol>
<li>它们发生的概率是$P(x_i)$， 各自的信息熵是$I(x_i)=-log(P(x_i))$</li>
<li>同时发生的概率是$\prod_{i=0}^nP(x_i)$</li>
<li>同时发生的信息熵是$I(x)=-log(\prod_{i=0}^nP(x_i))=-(\Sigma_{i=0}^nP(x_i))=\Sigma_{i=0}^n I(x_i)$</li>
</ol>
</li>
</ol>
<p>所以这样定义的<strong>信息量</strong>是满足要求的。</p>
<p>然后，定义<strong>信息熵</strong>为满足概率分布$P$的事件所产生的<strong>期望信息量</strong>：$H(P)=E_{X\sim P}[I(x)]=-E_{X\sim P}[logP(x)]=-\Sigma_iP(x_i)log(P(x_i))$。显然的，$H(P)$和$I(x)$是满足性质2的。</p>
<p>综上，我们得到了信息熵的定义，也知道信息熵可以作为<strong>分布</strong>的度量。</p>
<h2 id="KL散度">KL散度</h2>
<p>一个神经网络，可以看作一个映射，就是有点复杂🧠，其功能是把一个<strong>输入空间</strong>映射到一个<strong>预测空间</strong>，对应这个<strong>输入空间</strong>我们还有一个<strong>标签空间</strong>也就是<strong>真实空间</strong>。</p>
<p>显然我们希望自己的<strong>预测空间</strong>和<strong>真实空间</strong>越像越好，那么有没有什么办法，衡量这两个空间是不是“相似”呢？答案是显然的，只要看一看上面的关于<strong>熵</strong>的讨论，我们就能意识到，所谓空间其实就是规定了$X\sim P(X)$，所以事实上我们是可以使用概率分布来描述一个空间的分布。那么既然可以使用<strong>熵</strong>来描述一个空间本身的分布，自然就可以使用类似的概念来描述两个空间之间的<strong>分布的差异</strong>。</p>
<p>而相对熵，也就是KL散度，就可以衡量两个概率分布之间的近似程度。类似于熵，相对熵在两个分布十分相近的时候处于一个很小的值。</p>
<p>下面的时对KL散度的定义，假设我们有两个概率分布，原始分布$P$与近似分布$Q$，然后得到：<br>
$$<br>
\begin{cases}<br>
KL(P||Q)=\Sigma_i P(x_i)log(\frac{P(x_i)}{Q(x_i)}) —— \small{离散状态} \<br>
KL(P||Q)=\int p(x)\frac{p(x)}{q(x)}——连续状态<br>
\end{cases}<br>
$$</p>
<p>对应的可以写成期望的形式：$KL(P||Q)=\mathbb{E}[log(p(x))-log(q(x))]$</p>
<p>从这个定义中就可以看出，当原始分布和近似分布完全一致时，KL散度就为0；而其期望的形式也能解释为<strong>原始分布和近似分布之间对数之差的期望</strong></p>
<h2 id="交叉熵">交叉熵</h2>
<p>显然，使用KL散度作为衡量两个分布之间的指标已经是一个很好的选择，但是如果能把它再简化简化又何乐而不为呢？</p>
<p>$$<br>
\begin{align*}<br>
KL(P||Q) &amp;= \sum_i P(x_i) \log\left(\frac{P(x_i)}{Q(x_i)}\right) \<br>
&amp;= \sum_i \left(P(x_i) \log(P(x_i)) - P(x_i) \log(Q(x_i))\right) \<br>
&amp;= -H(P) - \sum_i P(x_i) \log(Q(x_i))<br>
\end{align*}<br>
$$</p>
<p>这里，我们发现$-H(P)$是由<strong>原始分布</strong>，这一项在深度学习中是由提供的数据集决定的，也就是一个定值；而后一项才决定了KL散度，所以，我们可以只计算后一项$-\Sigma_iP(x_i)log(Q(x_i))$，我们称这一项为<strong>交叉熵</strong>。</p>
<p>这里给出交叉熵的定义：对于两个分布$P$和$Q$，其中$P$是真实分布，$Q$是预测分布/近似分布，我们可以定义交叉熵为：</p>
<p>$$<br>
H(P,Q)=-E_{X\sim P}[logQ(x)]=-\Sigma_iP(x_i)log(Q(x_i))<br>
$$</p>
<blockquote>
<p>这样，我们确定了信息熵($H(P)$)，相对熵/KL散度($KL(P||Q)$)和交叉熵($H(P,Q)$)之间的关系:</p>
<p>$$<br>
KL(P||Q) = -H(P) + H(P,Q)<br>
$$</p>
<p>当原始分布P保持不变时，最小化KL散度等价于最小化交叉熵， 而交叉熵常作为机器学习的损失函数！</p>
</blockquote>
<h2 id="交叉熵与模型参数">交叉熵与模型参数</h2>
<blockquote>
<p>好叭，我们上面谈了一些数学上的问题，并且引出了一个重要的概念<strong>交叉熵</strong>，可是这个交叉熵和我们的模型有什么关系呢？</p>
</blockquote>
<p>$$<br>
H(P,Q)=-E_{X\sim P}[logQ(x)]=-\Sigma_iP(x_i)log(Q(x_i))<br>
$$</p>
<p>这里的$Q$是近似分布，而我们前文也提到了一个神经网络的最简洁的形式是：$\hat{Y} = F(X, \theta), \hat{Y} \in R^{(s,m)}, X \in R^{(s, n)}$。</p>
<p>那么，事情就变得明了了，因为这里的$\hat Y$和$Q$是等价的，它们都是模型（也就是神经网络）预测的分布。那么，就会有$H(P,Q)=H(P,\hat{Y})=\mathbb{H}(P, \theta, X)$，这里的$X$完全由输入数据库本身决定，和$P$一样，所以可以进一步得到$H(P,Q)=\mathfrak{H}(\theta)$。</p>
<p>也就是说交叉熵仅仅和模型中参数有关！！</p>
<blockquote>
<p>为了简单起见，后文的$\mathfrak{H}(\theta)$就写作$loss(\theta)$，也即是损失函数。因为在深度学习中根据任务的不同会使用不同形式的<strong>损失函数</strong>，但是交叉熵是最常见的损失函数，所以我们这里就是以交叉熵作为一个示例来说明。</p>
</blockquote>
<h1>优化损失函数</h1>
<h2 id="优化的对象">优化的对象</h2>
<p>在上文的一顿推导后，我们得到了一个指标$loss$——损失函数，这个指标仅仅和模型的参数也就是$\theta$有关，但是可以很好的反应预测空间和真实空间之间的差异，并且有着明确的相关，也就是$loss$越小，两个空间之间的差异越小。这样一来，我们在一开始提出的问题就具体化为：<strong>寻找一个$\theta^*$使$loss(\theta)$尽可能的小</strong>。</p>
<blockquote>
<p>这里我不太确定为啥叫“损失函数”，明明是“损失熵”更合理？我觉得可能是因为这个“熵”是和$\theta$相关的，当$\theta$改变的时候表现的像一个函数，所以叫做“损失函数”</p>
<p>注意，虽然我们是期待有一个唯一的$\theta^*$可以实现这样的效果，但是到底有没有、是不是一个，似乎还是不是很确定。但是这对我们的操作的影响不大，只要我们能在一个确定的输入分布（对应某一个数据集）下得到一个好的$\hat{\theta}$就可以了！</p>
</blockquote>
<p>好叭，正如上一节说的，一个模型中会有很多的参数，而且模型一开始都是随机初始化得到的$\theta_{init}$，所以获得我们需要的那个$\hat{\theta}$并不是一件容易的事情。幸运的是，<strong>梯度优化</strong>可以帮我们实现这一点。</p>
<blockquote>
<p>虽然初始化参数也是有相应的方法，但是这里先不做讨论。</p>
</blockquote>
<h2 id="梯度优化">梯度优化</h2>
<p>简单的说，我们是通过梯度优化逐步得到期待的$\hat \theta$的：</p>
<p>$$<br>
\theta_t = \theta_{t-1} - \mu \cdot \nabla loss(\theta_{t-1})<br>
$$</p>
<blockquote>
<p>我想这里应该是比较好理解的，应该是在多元函数的微分那个部分有证明函数的梯度指向的是函数下降的方向，那么根据$loss(\theta)$的梯度$\nabla loss(\theta)$优化$\theta$自然就是一个好的选择。</p>
<p>这里的$\mu$是学习率，也就是一次优化参数变化的步长。</p>
</blockquote>
<p>为了直观的说明如何通过梯度下降的方法从初始化的$\theta_{init}$得到期待的$\hat \theta$，我们这里不妨先考虑一个“理想模型”，这里模型中只有两个参数$\theta_1$和$\theta_2$，对应的$loss$就是一个二元函数，如下图：</p>
<p><img src="%E6%A2%AF%E5%BA%A6-%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96.gif" alt="梯度优化"></p>
<p>这里给出了几种不同的梯度优化的方法，但是我们可以先不考虑它们具体是怎么操作的，知道它们都是依赖于$\nabla loss(\theta)$就可以了。</p>
<h2 id="链式法则">链式法则</h2>
<p>上文中，我们说明了，实现参数优化的方法是梯度优化，而梯度优化中必不可少的操作就是计算函数的梯度也就是$\nabla loss(\theta)$。</p>
<p>但是，这样的计算并不是一件容易的事情，在多层感知器（MLP）中，损失函数通常在输出层计算，然后通过反向传播算法将误差逐层传递回去。假设我们有一个三层的MLP，损失函数 ( L ) 通常是输出层的预测值 ( \hat{y} ) 与真实值 ( y ) 之间的差异。损失函数的一个常见形式是均方误差（MSE）：</p>
<p>$ L = \frac{1}{2}(\hat{y} - y)^2 $</p>
<p>为了展示反向传播和链式法则，我们需要计算损失函数 ( L ) 对每个权重 ( w ) 和偏置 ( b ) 的偏导数。以下是三层MLP中损失函数对第一层权重 ( w^{(1)} ) 和偏置 ( b^{(1)} ) 的偏导数的一般形式：</p>
<p>$ \frac{\partial L}{\partial w^{(1)}} = \frac{\partial L}{\partial z^{(2)}} \cdot \frac{\partial z^{(2)}}{\partial a^{(2)}} \cdot \frac{\partial a^{(2)}}{\partial z^{(1)}} \cdot \frac{\partial z^{(1)}}{\partial w^{(1)}} $<br>
$ \frac{\partial L}{\partial b^{(1)}} = \frac{\partial L}{\partial z^{(2)}} \cdot \frac{\partial z^{(2)}}{\partial a^{(2)}} \cdot \frac{\partial a^{(2)}}{\partial z^{(1)}} \cdot \frac{\partial z^{(1)}}{\partial b^{(1)}} $</p>
<p>其中：</p>
<ul>
<li>( z^{(1)} = w^{(1)} \cdot x + b^{(1)} ) 是第一层的输入加权和加上偏置。</li>
<li>( a^{(1)} = \sigma(z^{(1)}) ) 是第一层的激活函数输出。</li>
<li>( z^{(2)} = w^{(2)} \cdot a^{(1)} + b^{(2)} ) 是第二层的输入。</li>
<li>( a^{(2)} = \sigma(z^{(2)}) ) 是第二层的激活函数输出。</li>
<li>( \hat{y} = w^{(3)} \cdot a^{(2)} + b^{(3)} ) 是最终的预测值。</li>
<li>( \sigma ) 是激活函数，比如 sigmoid 或 ReLU。</li>
</ul>
<blockquote>
<p>pytorch是现在最流行的DL的框架，在pytorch中，$\nabla loss(\theta^i_t)$也即是某一个时间步中的某一个参数的梯度就是通过这样的反向传播的方法计算得到的，并且以$(\theta_t^i, \nabla loss(\theta^i_t))$的形式加以保持，这样会增加显存的开销，但是可以减少计算的时间。</p>
</blockquote>
<h1>小结</h1>
<p>在这一节中，我们分析了如何得到模型的“合适的参数”。我们首先通过交叉熵量化模型的参数的“合适的程度”，然后使用梯度优化的方法，不断的调整$\theta_{init}$使之不断的接近目标$\hat \theta$。为了实现这样的梯度优化，我们需要高效的计算$\nabla loss(\theta^i_t)$，而这个任务在链式法则的保证下可以正常的进行。</p>
<p>我们还没有讲梯度优化的具体算法有那些，也没有讲学习率要怎么调节，这些问题讲起来也要花上很久的时间，这里先按下不表。</p>
<p>总而言之，通过这两节，我们大概就说清楚了一个神经网络的forward和backward的操作思路，至于剩下的细小的方法会慢慢补完，敬请期待！🥳</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
</search>
